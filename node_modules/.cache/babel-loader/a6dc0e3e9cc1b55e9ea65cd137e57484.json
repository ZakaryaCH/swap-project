{"ast":null,"code":"export {}; // import { isTradeBetter } from \"utils/trades\";\n// import { Currency, CurrencyAmount, Pair, Token, Trade } from \"@uniswap/sdk\";\n// import flatMap from \"lodash.flatmap\";\n// import { useMemo } from \"react\";\n// import { BETTER_TRADE_LESS_HOPS_THRESHOLD } from \"../constants\";\n// import { PairState, usePairs } from \"../data/Reserves\";\n// // import { wrappedCurrency } from '../utils/wrappedCurrency'\n// import { useActiveWeb3React } from \"./index\";\n// import { useUnsupportedTokens } from \"./Tokens\";\n// import { useUserSingleHopOnly } from \"state/user/hooks\";\n// function useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n//   const { chainId } = useActiveWeb3React();\n//   // const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n//   // const [tokenA, tokenB] = chainId\n//   //   ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n//   //   : [undefined, undefined]\n//   // const basePairs: [Token, Token][] = useMemo(\n//   //   () =>\n//   //     flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase])).filter(\n//   //       ([t0, t1]) => t0.address !== t1.address\n//   //     ),\n//   //   [bases]\n//   // )\n//   // const allPairCombinations: [Token, Token][] = useMemo(\n//   //   () =>\n//   //     tokenA && tokenB\n//   //       ? [\n//   //           // the direct pair\n//   //           [tokenA, tokenB],\n//   //           // token A against all bases\n//   //           ...bases.map((base): [Token, Token] => [tokenA, base]),\n//   //           // token B against all bases\n//   //           ...bases.map((base): [Token, Token] => [tokenB, base]),\n//   //           // each base against all bases\n//   //           ...basePairs\n//   //         ]\n//   //           .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n//   //           .filter(([t0, t1]) => t0.address !== t1.address)\n//   //           .filter(([tokenA, tokenB]) => {\n//   //             if (!chainId) return true\n//   //             // const customBases = CUSTOM_BASES[chainId]\n//   //             // if (!customBases) return true\n//   //             // const customBasesA: Token[] | undefined = customBases[tokenA.address]\n//   //             // const customBasesB: Token[] | undefined = customBases[tokenB.address]\n//   //             // if (!customBasesA && !customBasesB) return true\n//   //             // if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false\n//   //             // if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false\n//   //             return true\n//   //           })\n//   //       : [],\n//   //   [tokenA, tokenB, bases, basePairs, chainId]\n//   // )\n// //   const allPairs = usePairs(allPairCombinations);\n// //   // only pass along valid pairs, non-duplicated pairs\n// //   return useMemo(\n// //     () =>\n// //       Object.values(\n// //         allPairs\n// //           // filter out invalid pairs\n// //           .filter((result): result is [PairState.EXISTS, Pair] =>\n// //             Boolean(result[0] === PairState.EXISTS && result[1])\n// //           )\n// //           // filter out duplicated pairs\n// //           .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n// //             memo[curr.liquidityToken.address] =\n// //               memo[curr.liquidityToken.address] ?? curr;\n// //             return memo;\n// //           }, {})\n// //       ),\n// //     [allPairs]\n// //   );\n// // }\n// const MAX_HOPS = 3;\n// /**\n//  * Returns the best trade for the exact amount of tokens in to the given token out\n//  */\n// export function useTradeExactIn(\n//   currencyAmountIn?: CurrencyAmount,\n//   currencyOut?: Currency\n// ): Trade | null {\n//   const allowedPairs = useAllCommonPairs(\n//     currencyAmountIn?.currency,\n//     currencyOut\n//   );\n//   const [singleHopOnly] = useUserSingleHopOnly();\n//   return useMemo(() => {\n//     if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n//       if (singleHopOnly) {\n//         return (\n//           Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n//             maxHops: 1,\n//             maxNumResults: 1,\n//           })[0] ?? null\n//         );\n//       }\n//       // search through trades with varying hops, find best trade out of them\n//       let bestTradeSoFar: Trade | null = null;\n//       for (let i = 1; i <= MAX_HOPS; i++) {\n//         const currentTrade: Trade | null =\n//           Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n//             maxHops: i,\n//             maxNumResults: 1,\n//           })[0] ?? null;\n//         // if current trade is best yet, save it\n//         if (\n//           isTradeBetter(\n//             bestTradeSoFar,\n//             currentTrade,\n//             BETTER_TRADE_LESS_HOPS_THRESHOLD\n//           )\n//         ) {\n//           bestTradeSoFar = currentTrade;\n//         }\n//       }\n//       return bestTradeSoFar;\n//     }\n//     return null;\n//   }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n// }\n// /**\n//  * Returns the best trade for the token in to the exact amount of token out\n//  */\n// export function useTradeExactOut(\n//   currencyIn?: Currency,\n//   currencyAmountOut?: CurrencyAmount\n// ): Trade | null {\n//   const allowedPairs = useAllCommonPairs(\n//     currencyIn,\n//     currencyAmountOut?.currency\n//   );\n//   const [singleHopOnly] = useUserSingleHopOnly();\n//   return useMemo(() => {\n//     if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n//       if (singleHopOnly) {\n//         return (\n//           Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n//             maxHops: 1,\n//             maxNumResults: 1,\n//           })[0] ?? null\n//         );\n//       }\n//       // search through trades with varying hops, find best trade out of them\n//       let bestTradeSoFar: Trade | null = null;\n//       for (let i = 1; i <= MAX_HOPS; i++) {\n//         const currentTrade =\n//           Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n//             maxHops: i,\n//             maxNumResults: 1,\n//           })[0] ?? null;\n//         if (\n//           isTradeBetter(\n//             bestTradeSoFar,\n//             currentTrade,\n//             BETTER_TRADE_LESS_HOPS_THRESHOLD\n//           )\n//         ) {\n//           bestTradeSoFar = currentTrade;\n//         }\n//       }\n//       return bestTradeSoFar;\n//     }\n//     return null;\n//   }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n// }\n// export function useIsTransactionUnsupported(\n//   currencyIn?: Currency,\n//   currencyOut?: Currency\n// ): boolean {\n//   const unsupportedToken: { [address: string]: Token } = useUnsupportedTokens();\n//   const { chainId } = useActiveWeb3React();\n//   // const tokenIn = wrappedCurrency(currencyIn, chainId)\n//   // const tokenOut = wrappedCurrency(currencyOut, chainId)\n//   // if unsupported list loaded & either token on list, mark as unsupported\n//   if (unsupportedToken) {\n//     // if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n//     //   return true\n//     // }\n//     // if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n//     //   return true\n//     // }\n//   }\n//   return false;\n// }","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/Trades.ts"],"names":[],"mappings":"AAAA,U,CACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["export {};\n// import { isTradeBetter } from \"utils/trades\";\n// import { Currency, CurrencyAmount, Pair, Token, Trade } from \"@uniswap/sdk\";\n// import flatMap from \"lodash.flatmap\";\n// import { useMemo } from \"react\";\n\n// import { BETTER_TRADE_LESS_HOPS_THRESHOLD } from \"../constants\";\n// import { PairState, usePairs } from \"../data/Reserves\";\n// // import { wrappedCurrency } from '../utils/wrappedCurrency'\n\n// import { useActiveWeb3React } from \"./index\";\n// import { useUnsupportedTokens } from \"./Tokens\";\n// import { useUserSingleHopOnly } from \"state/user/hooks\";\n\n// function useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n//   const { chainId } = useActiveWeb3React();\n\n//   // const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n\n//   // const [tokenA, tokenB] = chainId\n//   //   ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n//   //   : [undefined, undefined]\n\n//   // const basePairs: [Token, Token][] = useMemo(\n//   //   () =>\n//   //     flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase])).filter(\n//   //       ([t0, t1]) => t0.address !== t1.address\n//   //     ),\n//   //   [bases]\n//   // )\n\n//   // const allPairCombinations: [Token, Token][] = useMemo(\n//   //   () =>\n//   //     tokenA && tokenB\n//   //       ? [\n//   //           // the direct pair\n//   //           [tokenA, tokenB],\n//   //           // token A against all bases\n//   //           ...bases.map((base): [Token, Token] => [tokenA, base]),\n//   //           // token B against all bases\n//   //           ...bases.map((base): [Token, Token] => [tokenB, base]),\n//   //           // each base against all bases\n//   //           ...basePairs\n//   //         ]\n//   //           .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n//   //           .filter(([t0, t1]) => t0.address !== t1.address)\n//   //           .filter(([tokenA, tokenB]) => {\n//   //             if (!chainId) return true\n//   //             // const customBases = CUSTOM_BASES[chainId]\n//   //             // if (!customBases) return true\n\n//   //             // const customBasesA: Token[] | undefined = customBases[tokenA.address]\n//   //             // const customBasesB: Token[] | undefined = customBases[tokenB.address]\n\n//   //             // if (!customBasesA && !customBasesB) return true\n\n//   //             // if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false\n//   //             // if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false\n\n//   //             return true\n//   //           })\n//   //       : [],\n//   //   [tokenA, tokenB, bases, basePairs, chainId]\n//   // )\n\n// //   const allPairs = usePairs(allPairCombinations);\n\n// //   // only pass along valid pairs, non-duplicated pairs\n// //   return useMemo(\n// //     () =>\n// //       Object.values(\n// //         allPairs\n// //           // filter out invalid pairs\n// //           .filter((result): result is [PairState.EXISTS, Pair] =>\n// //             Boolean(result[0] === PairState.EXISTS && result[1])\n// //           )\n// //           // filter out duplicated pairs\n// //           .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n// //             memo[curr.liquidityToken.address] =\n// //               memo[curr.liquidityToken.address] ?? curr;\n// //             return memo;\n// //           }, {})\n// //       ),\n// //     [allPairs]\n// //   );\n// // }\n\n// const MAX_HOPS = 3;\n\n// /**\n//  * Returns the best trade for the exact amount of tokens in to the given token out\n//  */\n// export function useTradeExactIn(\n//   currencyAmountIn?: CurrencyAmount,\n//   currencyOut?: Currency\n// ): Trade | null {\n//   const allowedPairs = useAllCommonPairs(\n//     currencyAmountIn?.currency,\n//     currencyOut\n//   );\n\n//   const [singleHopOnly] = useUserSingleHopOnly();\n\n//   return useMemo(() => {\n//     if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n//       if (singleHopOnly) {\n//         return (\n//           Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n//             maxHops: 1,\n//             maxNumResults: 1,\n//           })[0] ?? null\n//         );\n//       }\n//       // search through trades with varying hops, find best trade out of them\n//       let bestTradeSoFar: Trade | null = null;\n//       for (let i = 1; i <= MAX_HOPS; i++) {\n//         const currentTrade: Trade | null =\n//           Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n//             maxHops: i,\n//             maxNumResults: 1,\n//           })[0] ?? null;\n//         // if current trade is best yet, save it\n//         if (\n//           isTradeBetter(\n//             bestTradeSoFar,\n//             currentTrade,\n//             BETTER_TRADE_LESS_HOPS_THRESHOLD\n//           )\n//         ) {\n//           bestTradeSoFar = currentTrade;\n//         }\n//       }\n//       return bestTradeSoFar;\n//     }\n\n//     return null;\n//   }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n// }\n\n// /**\n//  * Returns the best trade for the token in to the exact amount of token out\n//  */\n// export function useTradeExactOut(\n//   currencyIn?: Currency,\n//   currencyAmountOut?: CurrencyAmount\n// ): Trade | null {\n//   const allowedPairs = useAllCommonPairs(\n//     currencyIn,\n//     currencyAmountOut?.currency\n//   );\n\n//   const [singleHopOnly] = useUserSingleHopOnly();\n\n//   return useMemo(() => {\n//     if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n//       if (singleHopOnly) {\n//         return (\n//           Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n//             maxHops: 1,\n//             maxNumResults: 1,\n//           })[0] ?? null\n//         );\n//       }\n//       // search through trades with varying hops, find best trade out of them\n//       let bestTradeSoFar: Trade | null = null;\n//       for (let i = 1; i <= MAX_HOPS; i++) {\n//         const currentTrade =\n//           Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n//             maxHops: i,\n//             maxNumResults: 1,\n//           })[0] ?? null;\n//         if (\n//           isTradeBetter(\n//             bestTradeSoFar,\n//             currentTrade,\n//             BETTER_TRADE_LESS_HOPS_THRESHOLD\n//           )\n//         ) {\n//           bestTradeSoFar = currentTrade;\n//         }\n//       }\n//       return bestTradeSoFar;\n//     }\n//     return null;\n//   }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n// }\n\n// export function useIsTransactionUnsupported(\n//   currencyIn?: Currency,\n//   currencyOut?: Currency\n// ): boolean {\n//   const unsupportedToken: { [address: string]: Token } = useUnsupportedTokens();\n//   const { chainId } = useActiveWeb3React();\n\n//   // const tokenIn = wrappedCurrency(currencyIn, chainId)\n//   // const tokenOut = wrappedCurrency(currencyOut, chainId)\n\n//   // if unsupported list loaded & either token on list, mark as unsupported\n//   if (unsupportedToken) {\n//     // if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n//     //   return true\n//     // }\n//     // if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n//     //   return true\n//     // }\n//   }\n\n//   return false;\n// }\n"]},"metadata":{},"sourceType":"module"}