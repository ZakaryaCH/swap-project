{"ast":null,"code":"// import { DEFAULT_ACTIVE_LIST_URLS } from './../../constants/lists'\n// import { createReducer } from '@reduxjs/toolkit'\n// import { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists'\n// import { TokenList } from '@uniswap/token-lists/dist/types'\n// import { DEFAULT_LIST_OF_LISTS } from '../../constants/lists'\n// import { updateVersion } from '../global/actions'\n// import { acceptListUpdate, addList, fetchTokenList, removeList, enableList, disableList } from './actions'\n// export interface ListsState {\n//   readonly byUrl: {\n//     readonly [url: string]: {\n//       readonly current: TokenList | null\n//       readonly pendingUpdate: TokenList | null\n//       readonly loadingRequestId: string | null\n//       readonly error: string | null\n//     }\n//   }\n//   // this contains the default list of lists from the last time the updateVersion was called, i.e. the app was reloaded\n//   readonly lastInitializedDefaultListOfLists?: string[]\n//   // currently active lists\n//   readonly activeListUrls: string[] | undefined\n// }\n// type ListState = ListsState['byUrl'][string]\n// const NEW_LIST_STATE: ListState = {\n//   error: null,\n//   current: null,\n//   loadingRequestId: null,\n//   pendingUpdate: null\n// }\n// type Mutable<T> = { -readonly [P in keyof T]: T[P] extends ReadonlyArray<infer U> ? U[] : T[P] }\n// const initialState: ListsState = {\n//   lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n//   byUrl: {\n//     ...DEFAULT_LIST_OF_LISTS.reduce<Mutable<ListsState['byUrl']>>((memo, listUrl) => {\n//       memo[listUrl] = NEW_LIST_STATE\n//       return memo\n//     }, {})\n//   },\n//   activeListUrls: DEFAULT_ACTIVE_LIST_URLS\n// }\n// export default createReducer(initialState, builder =>\n//   builder\n//     .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {\n//       state.byUrl[url] = {\n//         current: null,\n//         pendingUpdate: null,\n//         ...state.byUrl[url],\n//         loadingRequestId: requestId,\n//         error: null\n//       }\n//     })\n//     .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {\n//       const current = state.byUrl[url]?.current\n//       const loadingRequestId = state.byUrl[url]?.loadingRequestId\n//       // no-op if update does nothing\n//       if (current) {\n//         const upgradeType = getVersionUpgrade(current.version, tokenList.version)\n//         if (upgradeType === VersionUpgrade.NONE) return\n//         if (loadingRequestId === null || loadingRequestId === requestId) {\n//           state.byUrl[url] = {\n//             ...state.byUrl[url],\n//             loadingRequestId: null,\n//             error: null,\n//             current: current,\n//             pendingUpdate: tokenList\n//           }\n//         }\n//       } else {\n//         // activate if on default active\n//         if (DEFAULT_ACTIVE_LIST_URLS.includes(url)) {\n//           state.activeListUrls?.push(url)\n//         }\n//         state.byUrl[url] = {\n//           ...state.byUrl[url],\n//           loadingRequestId: null,\n//           error: null,\n//           current: tokenList,\n//           pendingUpdate: null\n//         }\n//       }\n//     })\n//     .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {\n//       if (state.byUrl[url]?.loadingRequestId !== requestId) {\n//         // no-op since it's not the latest request\n//         return\n//       }\n//       state.byUrl[url] = {\n//         ...state.byUrl[url],\n//         loadingRequestId: null,\n//         error: errorMessage,\n//         current: null,\n//         pendingUpdate: null\n//       }\n//     })\n//     .addCase(addList, (state, { payload: url }) => {\n//       if (!state.byUrl[url]) {\n//         state.byUrl[url] = NEW_LIST_STATE\n//       }\n//     })\n//     .addCase(removeList, (state, { payload: url }) => {\n//       if (state.byUrl[url]) {\n//         delete state.byUrl[url]\n//       }\n//       // remove list from active urls if needed\n//       if (state.activeListUrls && state.activeListUrls.includes(url)) {\n//         state.activeListUrls = state.activeListUrls.filter(u => u !== url)\n//       }\n//     })\n//     .addCase(enableList, (state, { payload: url }) => {\n//       if (!state.byUrl[url]) {\n//         state.byUrl[url] = NEW_LIST_STATE\n//       }\n//       if (state.activeListUrls && !state.activeListUrls.includes(url)) {\n//         state.activeListUrls.push(url)\n//       }\n//       if (!state.activeListUrls) {\n//         state.activeListUrls = [url]\n//       }\n//     })\n//     .addCase(disableList, (state, { payload: url }) => {\n//       if (state.activeListUrls && state.activeListUrls.includes(url)) {\n//         state.activeListUrls = state.activeListUrls.filter(u => u !== url)\n//       }\n//     })\n//     .addCase(acceptListUpdate, (state, { payload: url }) => {\n//       if (!state.byUrl[url]?.pendingUpdate) {\n//         throw new Error('accept list update called without pending update')\n//       }\n//       state.byUrl[url] = {\n//         ...state.byUrl[url],\n//         pendingUpdate: null,\n//         current: state.byUrl[url].pendingUpdate\n//       }\n//     })\n//     .addCase(updateVersion, state => {\n//       // state loaded from localStorage, but new lists have never been initialized\n//       if (!state.lastInitializedDefaultListOfLists) {\n//         state.byUrl = initialState.byUrl\n//         state.activeListUrls = initialState.activeListUrls\n//       } else if (state.lastInitializedDefaultListOfLists) {\n//         const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\n//           (s, l) => s.add(l),\n//           new Set()\n//         )\n//         const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\n//         DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n//           if (!lastInitializedSet.has(listUrl)) {\n//             state.byUrl[listUrl] = NEW_LIST_STATE\n//           }\n//         })\n//         state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n//           if (!newListOfListsSet.has(listUrl)) {\n//             delete state.byUrl[listUrl]\n//           }\n//         })\n//       }\n//       state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\n//       // if no active lists, activate defaults\n//       if (!state.activeListUrls) {\n//         state.activeListUrls = DEFAULT_ACTIVE_LIST_URLS\n//         // for each list on default list, initialize if needed\n//         DEFAULT_ACTIVE_LIST_URLS.map((listUrl: string) => {\n//           if (!state.byUrl[listUrl]) {\n//             state.byUrl[listUrl] = NEW_LIST_STATE\n//           }\n//           return true\n//         })\n//       }\n//     })\n// )","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/state/lists/reducer.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import { DEFAULT_ACTIVE_LIST_URLS } from './../../constants/lists'\n// import { createReducer } from '@reduxjs/toolkit'\n// import { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists'\n// import { TokenList } from '@uniswap/token-lists/dist/types'\n// import { DEFAULT_LIST_OF_LISTS } from '../../constants/lists'\n// import { updateVersion } from '../global/actions'\n// import { acceptListUpdate, addList, fetchTokenList, removeList, enableList, disableList } from './actions'\n\n// export interface ListsState {\n//   readonly byUrl: {\n//     readonly [url: string]: {\n//       readonly current: TokenList | null\n//       readonly pendingUpdate: TokenList | null\n//       readonly loadingRequestId: string | null\n//       readonly error: string | null\n//     }\n//   }\n//   // this contains the default list of lists from the last time the updateVersion was called, i.e. the app was reloaded\n//   readonly lastInitializedDefaultListOfLists?: string[]\n\n//   // currently active lists\n//   readonly activeListUrls: string[] | undefined\n// }\n\n// type ListState = ListsState['byUrl'][string]\n\n// const NEW_LIST_STATE: ListState = {\n//   error: null,\n//   current: null,\n//   loadingRequestId: null,\n//   pendingUpdate: null\n// }\n\n// type Mutable<T> = { -readonly [P in keyof T]: T[P] extends ReadonlyArray<infer U> ? U[] : T[P] }\n\n// const initialState: ListsState = {\n//   lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n//   byUrl: {\n//     ...DEFAULT_LIST_OF_LISTS.reduce<Mutable<ListsState['byUrl']>>((memo, listUrl) => {\n//       memo[listUrl] = NEW_LIST_STATE\n//       return memo\n//     }, {})\n//   },\n//   activeListUrls: DEFAULT_ACTIVE_LIST_URLS\n// }\n\n// export default createReducer(initialState, builder =>\n//   builder\n//     .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {\n//       state.byUrl[url] = {\n//         current: null,\n//         pendingUpdate: null,\n//         ...state.byUrl[url],\n//         loadingRequestId: requestId,\n//         error: null\n//       }\n//     })\n//     .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {\n//       const current = state.byUrl[url]?.current\n//       const loadingRequestId = state.byUrl[url]?.loadingRequestId\n\n//       // no-op if update does nothing\n//       if (current) {\n//         const upgradeType = getVersionUpgrade(current.version, tokenList.version)\n\n//         if (upgradeType === VersionUpgrade.NONE) return\n//         if (loadingRequestId === null || loadingRequestId === requestId) {\n//           state.byUrl[url] = {\n//             ...state.byUrl[url],\n//             loadingRequestId: null,\n//             error: null,\n//             current: current,\n//             pendingUpdate: tokenList\n//           }\n//         }\n//       } else {\n//         // activate if on default active\n//         if (DEFAULT_ACTIVE_LIST_URLS.includes(url)) {\n//           state.activeListUrls?.push(url)\n//         }\n\n//         state.byUrl[url] = {\n//           ...state.byUrl[url],\n//           loadingRequestId: null,\n//           error: null,\n//           current: tokenList,\n//           pendingUpdate: null\n//         }\n//       }\n//     })\n//     .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {\n//       if (state.byUrl[url]?.loadingRequestId !== requestId) {\n//         // no-op since it's not the latest request\n//         return\n//       }\n\n//       state.byUrl[url] = {\n//         ...state.byUrl[url],\n//         loadingRequestId: null,\n//         error: errorMessage,\n//         current: null,\n//         pendingUpdate: null\n//       }\n//     })\n//     .addCase(addList, (state, { payload: url }) => {\n//       if (!state.byUrl[url]) {\n//         state.byUrl[url] = NEW_LIST_STATE\n//       }\n//     })\n//     .addCase(removeList, (state, { payload: url }) => {\n//       if (state.byUrl[url]) {\n//         delete state.byUrl[url]\n//       }\n//       // remove list from active urls if needed\n//       if (state.activeListUrls && state.activeListUrls.includes(url)) {\n//         state.activeListUrls = state.activeListUrls.filter(u => u !== url)\n//       }\n//     })\n//     .addCase(enableList, (state, { payload: url }) => {\n//       if (!state.byUrl[url]) {\n//         state.byUrl[url] = NEW_LIST_STATE\n//       }\n\n//       if (state.activeListUrls && !state.activeListUrls.includes(url)) {\n//         state.activeListUrls.push(url)\n//       }\n\n//       if (!state.activeListUrls) {\n//         state.activeListUrls = [url]\n//       }\n//     })\n//     .addCase(disableList, (state, { payload: url }) => {\n//       if (state.activeListUrls && state.activeListUrls.includes(url)) {\n//         state.activeListUrls = state.activeListUrls.filter(u => u !== url)\n//       }\n//     })\n//     .addCase(acceptListUpdate, (state, { payload: url }) => {\n//       if (!state.byUrl[url]?.pendingUpdate) {\n//         throw new Error('accept list update called without pending update')\n//       }\n//       state.byUrl[url] = {\n//         ...state.byUrl[url],\n//         pendingUpdate: null,\n//         current: state.byUrl[url].pendingUpdate\n//       }\n//     })\n//     .addCase(updateVersion, state => {\n//       // state loaded from localStorage, but new lists have never been initialized\n//       if (!state.lastInitializedDefaultListOfLists) {\n//         state.byUrl = initialState.byUrl\n//         state.activeListUrls = initialState.activeListUrls\n//       } else if (state.lastInitializedDefaultListOfLists) {\n//         const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\n//           (s, l) => s.add(l),\n//           new Set()\n//         )\n//         const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\n\n//         DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n//           if (!lastInitializedSet.has(listUrl)) {\n//             state.byUrl[listUrl] = NEW_LIST_STATE\n//           }\n//         })\n\n//         state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n//           if (!newListOfListsSet.has(listUrl)) {\n//             delete state.byUrl[listUrl]\n//           }\n//         })\n//       }\n\n//       state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\n\n//       // if no active lists, activate defaults\n//       if (!state.activeListUrls) {\n//         state.activeListUrls = DEFAULT_ACTIVE_LIST_URLS\n\n//         // for each list on default list, initialize if needed\n//         DEFAULT_ACTIVE_LIST_URLS.map((listUrl: string) => {\n//           if (!state.byUrl[listUrl]) {\n//             state.byUrl[listUrl] = NEW_LIST_STATE\n//           }\n//           return true\n//         })\n//       }\n//     })\n// )\n"]},"metadata":{},"sourceType":"module"}