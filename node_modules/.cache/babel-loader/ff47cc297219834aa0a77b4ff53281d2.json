{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { ETHER, Pair, Route, Token, TokenAmount, Trade, TradeType, WETH } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\n// import { useAllTokens } from \"../hooks/Tokens\";\nimport { useV1FactoryContract } from \"../hooks/useContract\";\nimport { Version } from \"../hooks/useToggledVersion\";\nimport { useSingleCallResult } from \"../state/multicall/hooks\";\nimport { useETHBalances, useTokenBalance } from \"../state/wallet/hooks\";\nexport function useV1ExchangeAddress(tokenAddress) {\n  _s();\n\n  var _useSingleCallResult, _useSingleCallResult$;\n\n  const contract = useV1FactoryContract();\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return (_useSingleCallResult = useSingleCallResult(contract, \"getExchange\", inputs)) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n}\n\n_s(useV1ExchangeAddress, \"diwIceYheILuw1PL3XW/X7/DaqM=\", false, function () {\n  return [useV1FactoryContract, useSingleCallResult];\n});\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount, tokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount));\n  }\n\n}\n\nfunction useMockV1Pair(inputCurrency) {\n  _s2();\n\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token === null || token === void 0 ? void 0 : token.address);\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress !== null && v1PairAddress !== void 0 ? v1PairAddress : \"\"];\n  return useMemo(() => token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined, [ETHBalance, inputCurrency, token, tokenBalance]);\n} // returns all v1 exchange addresses in the user's token list\n\n\n_s2(useMockV1Pair, \"UjsURM5xPXHcWilodqQuAyveaww=\", false, function () {\n  return [useV1ExchangeAddress, useTokenBalance, useETHBalances];\n});\n\nexport function useAllTokenV1Exchanges() {\n  _s3();\n\n  // const allTokens = useAllTokens();\n  const factory = useV1FactoryContract(); // const args = useMemo(\n  //   () => Object.keys(allTokens).map((tokenAddress) => [tokenAddress]),\n  //   [allTokens]\n  // );\n  // const data = useSingleContractMultipleData(\n  //   factory,\n  //   \"getExchange\",\n  //   args,\n  //   NEVER_RELOAD\n  // );\n  // return useMemo(\n  //   () =>\n  //     data?.reduce<{ [exchangeAddress: string]: Token }>(\n  //       (memo, { result }, ix) => {\n  //         if (result?.[0] && result[0] !== AddressZero) {\n  //           memo[result[0]] = allTokens[args[ix][0]];\n  //         }\n  //         return memo;\n  //       },\n  //       {}\n  //     ) ?? {},\n  //   [allTokens, args, data]\n  // );\n} // returns whether any of the tokens in the user's token list have liquidity on v1\n// export function useUserHasLiquidityInAllTokens(): boolean | undefined {\n//   const { account, chainId } = useActiveWeb3React()\n//   const exchanges = useAllTokenV1Exchanges()\n//   const v1ExchangeLiquidityTokens = useMemo(\n//     () =>\n//       chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n//     [chainId, exchanges]\n//   )\n//   const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n//   return useMemo(\n//     () =>\n//       Object.keys(balances).some(tokenAddress => {\n//         const b = balances[tokenAddress]?.raw\n//         return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n//       }),\n//     [balances]\n//   )\n// }\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\n\n_s3(useAllTokenV1Exchanges, \"+CaXFzdIPmBjh1iJxoMTheR5VhA=\", false, function () {\n  return [useV1FactoryContract];\n});\n\nexport function useV1Trade(isExactIn, inputCurrency, outputCurrency, exactAmount) {\n  _s4();\n\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER; // construct a direct or through ETH v1 route\n\n  let pairs = [];\n\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  } // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n      pairs = [inputPair, outputPair];\n    }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade;\n\n  try {\n    v1Trade = route && exactAmount ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT) : undefined;\n  } catch (error) {\n    console.debug(\"Failed to create V1 trade\", error);\n  }\n\n  return v1Trade;\n}\n\n_s4(useV1Trade, \"0vh+JJLbgPh9RAcnEjiYjwnunbk=\", false, function () {\n  return [useMockV1Pair, useMockV1Pair];\n});\n\nexport function getTradeVersion(trade) {\n  var _trade$route, _trade$route$pairs;\n\n  const isV1 = trade === null || trade === void 0 ? void 0 : (_trade$route = trade.route) === null || _trade$route === void 0 ? void 0 : (_trade$route$pairs = _trade$route.pairs) === null || _trade$route$pairs === void 0 ? void 0 : _trade$route$pairs.some(pair => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n} // returns the v1 exchange against which a trade should be executed\n\nexport function useV1TradeExchangeAddress(trade) {\n  _s5();\n\n  const tokenAddress = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount ? trade.inputAmount.token.address : trade.outputAmount instanceof TokenAmount ? trade.outputAmount.token.address : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}\n\n_s5(useV1TradeExchangeAddress, \"dGMSMt3qM8GyaWcSoa4bZcqoiKw=\", false, function () {\n  return [useV1ExchangeAddress];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/data/V1.ts"],"names":["ETHER","Pair","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useV1FactoryContract","Version","useSingleCallResult","useETHBalances","useTokenBalance","useV1ExchangeAddress","tokenAddress","contract","inputs","result","MockV1Pair","constructor","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","factory","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","isV1","some","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount"],"mappings":"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","sourcesContent":["import { AddressZero } from \"@ethersproject/constants\";\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Pair,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH,\n} from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { useActiveWeb3React } from \"../hooks\";\n// import { useAllTokens } from \"../hooks/Tokens\";\nimport { useV1FactoryContract } from \"../hooks/useContract\";\nimport { Version } from \"../hooks/useToggledVersion\";\nimport {\n  NEVER_RELOAD,\n  useSingleCallResult,\n  useSingleContractMultipleData,\n} from \"../state/multicall/hooks\";\nimport {\n  useETHBalances,\n  useTokenBalance,\n  useTokenBalances,\n} from \"../state/wallet/hooks\";\n\nexport function useV1ExchangeAddress(\n  tokenAddress?: string\n): string | undefined {\n  const contract = useV1FactoryContract();\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return useSingleCallResult(contract, \"getExchange\", inputs)?.result?.[0];\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(\n      tokenAmount,\n      new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount)\n    );\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(\n    isWETH ? undefined : token?.address\n  );\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? \"\"];\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency\n        ? new MockV1Pair(ETHBalance.raw, tokenBalance)\n        : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  );\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  // const allTokens = useAllTokens();\n  const factory = useV1FactoryContract();\n  // const args = useMemo(\n  //   () => Object.keys(allTokens).map((tokenAddress) => [tokenAddress]),\n  //   [allTokens]\n  // );\n\n  // const data = useSingleContractMultipleData(\n  //   factory,\n  //   \"getExchange\",\n  //   args,\n  //   NEVER_RELOAD\n  // );\n\n  // return useMemo(\n  //   () =>\n  //     data?.reduce<{ [exchangeAddress: string]: Token }>(\n  //       (memo, { result }, ix) => {\n  //         if (result?.[0] && result[0] !== AddressZero) {\n  //           memo[result[0]] = allTokens[args[ix][0]];\n  //         }\n  //         return memo;\n  //       },\n  //       {}\n  //     ) ?? {},\n  //   [allTokens, args, data]\n  // );\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\n// export function useUserHasLiquidityInAllTokens(): boolean | undefined {\n//   const { account, chainId } = useActiveWeb3React()\n\n//   const exchanges = useAllTokenV1Exchanges()\n\n//   const v1ExchangeLiquidityTokens = useMemo(\n//     () =>\n//       chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n//     [chainId, exchanges]\n//   )\n\n//   const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n//   return useMemo(\n//     () =>\n//       Object.keys(balances).some(tokenAddress => {\n//         const b = balances[tokenAddress]?.raw\n//         return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n//       }),\n//     [balances]\n//   )\n// }\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER;\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = [];\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair];\n  }\n\n  const route =\n    inputCurrency &&\n    pairs &&\n    pairs.length > 0 &&\n    new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade: Trade | undefined;\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(\n            route,\n            exactAmount,\n            isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT\n          )\n        : undefined;\n  } catch (error) {\n    console.debug(\"Failed to create V1 trade\", error);\n  }\n  return v1Trade;\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some((pair) => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(\n  trade: Trade | undefined\n): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}\n"]},"metadata":{},"sourceType":"module"}