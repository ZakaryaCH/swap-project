{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$();\n\nimport { Pair, Token } from \"@uniswap/sdk\";\nimport ReactGA from \"react-ga\";\nimport { useCallback, useMemo } from \"react\";\nimport { shallowEqual, useDispatch, useSelector } from \"react-redux\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { addSerializedPair, addSerializedToken, removeSerializedToken, updateUserDarkMode, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance, toggleURLWarning, updateUserSingleHopOnly } from \"./actions\";\n\nfunction serializeToken(token) {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  };\n}\n\nfunction deserializeToken(serializedToken) {\n  return new Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);\n}\n\nexport function useIsDarkMode() {\n  _s();\n\n  const {\n    userDarkMode,\n    matchesDarkMode\n  } = useSelector(({\n    user: {\n      matchesDarkMode,\n      userDarkMode\n    }\n  }) => ({\n    userDarkMode,\n    matchesDarkMode\n  }), shallowEqual);\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\n\n_s(useIsDarkMode, \"fn6etfcHXfMs02JV/usc15XJU0k=\", false, function () {\n  return [useSelector];\n});\n\nexport function useDarkModeManager() {\n  _s2();\n\n  const dispatch = useDispatch();\n  const darkMode = useIsDarkMode();\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({\n      userDarkMode: !darkMode\n    }));\n  }, [darkMode, dispatch]);\n  return [darkMode, toggleSetDarkMode];\n}\n\n_s2(useDarkModeManager, \"C48Gp1zKEL4YakCYKMkkFweY0qg=\", false, function () {\n  return [useDispatch, useIsDarkMode];\n});\n\nexport function useIsExpertMode() {\n  _s3();\n\n  return useSelector(state => state.user.userExpertMode);\n}\n\n_s3(useIsExpertMode, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useExpertModeManager() {\n  _s4();\n\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\n\n_s4(useExpertModeManager, \"ULLfsmjCcahFerd6rXziokiA+RI=\", false, function () {\n  return [useDispatch, useIsExpertMode];\n});\n\nexport function useUserSingleHopOnly() {\n  _s5();\n\n  const dispatch = useDispatch();\n  const singleHopOnly = useSelector(state => state.user.userSingleHopOnly);\n  const setSingleHopOnly = useCallback(newSingleHopOnly => {\n    ReactGA.event({\n      category: \"Routing\",\n      action: newSingleHopOnly ? \"enable single hop\" : \"disable single hop\"\n    });\n    dispatch(updateUserSingleHopOnly({\n      userSingleHopOnly: newSingleHopOnly\n    }));\n  }, [dispatch]);\n  return [singleHopOnly, setSingleHopOnly];\n}\n\n_s5(useUserSingleHopOnly, \"WikX7qzoMFkBpAxkb0uK96O/O0E=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useUserSlippageTolerance() {\n  _s6();\n\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(userSlippageTolerance => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\n_s6(useUserSlippageTolerance, \"lO9PfBe6MbiNxNv0Q3TS/IyxyIE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useUserTransactionTTL() {\n  _s7();\n\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(userDeadline => {\n    dispatch(updateUserDeadline({\n      userDeadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\n\n_s7(useUserTransactionTTL, \"nR4EOlfoy/fKrJpN3ITukwrTqzM=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useAddUserToken() {\n  _s8();\n\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\n\n_s8(useAddUserToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useRemoveUserAddedToken() {\n  _s9();\n\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\n\n_s9(useRemoveUserAddedToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useUserAddedTokens() {\n  _s10();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const serializedTokensMap = useSelector(({\n    user: {\n      tokens\n    }\n  }) => tokens);\n  return useMemo(() => {\n    var _serializedTokensMap;\n\n    if (!chainId) return [];\n    return Object.values((_serializedTokensMap = serializedTokensMap[chainId]) !== null && _serializedTokensMap !== void 0 ? _serializedTokensMap : {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\n\n_s10(useUserAddedTokens, \"PdCPfDsyvt0iyDvIy6GqqMS0G5U=\", false, function () {\n  return [useActiveWeb3React, useSelector];\n});\n\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\n\nexport function usePairAdder() {\n  _s11();\n\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\n\n_s11(usePairAdder, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useURLWarningVisible() {\n  _s12();\n\n  return useSelector(state => state.user.URLWarningVisible);\n}\n\n_s12(useURLWarningVisible, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useURLWarningToggle() {\n  _s13();\n\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\n\n_s13(useURLWarningToggle, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function toV2LiquidityToken([tokenA, tokenB]) {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, \"UNI-V2\", \"Uniswap V2\");\n}\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\n\nexport function useTrackedTokenPairs() {\n  return null;\n}","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/state/user/hooks.tsx"],"names":["Pair","Token","ReactGA","useCallback","useMemo","shallowEqual","useDispatch","useSelector","useActiveWeb3React","addSerializedPair","addSerializedToken","removeSerializedToken","updateUserDarkMode","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","toggleURLWarning","updateUserSingleHopOnly","serializeToken","token","chainId","address","decimals","symbol","name","deserializeToken","serializedToken","useIsDarkMode","userDarkMode","matchesDarkMode","user","useDarkModeManager","dispatch","darkMode","toggleSetDarkMode","useIsExpertMode","state","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSingleHopOnly","singleHopOnly","userSingleHopOnly","setSingleHopOnly","newSingleHopOnly","event","category","action","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","useUserTransactionTTL","userDeadline","setUserDeadline","useAddUserToken","useRemoveUserAddedToken","useUserAddedTokens","serializedTokensMap","tokens","Object","values","map","serializePair","pair","token0","token1","usePairAdder","serializedPair","useURLWarningVisible","URLWarningVisible","useURLWarningToggle","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs"],"mappings":"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","sourcesContent":["import { ChainId, Pair, Token } from \"@uniswap/sdk\";\nimport flatMap from \"lodash.flatmap\";\nimport ReactGA from \"react-ga\";\nimport { useCallback, useMemo } from \"react\";\nimport { shallowEqual, useDispatch, useSelector } from \"react-redux\";\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS } from \"../../constants\";\n\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useAllTokens } from \"../../hooks/Tokens\";\nimport { AppDispatch, AppState } from \"../index\";\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateUserDarkMode,\n  updateUserDeadline,\n  updateUserExpertMode,\n  updateUserSlippageTolerance,\n  toggleURLWarning,\n  updateUserSingleHopOnly,\n} from \"./actions\";\n\nfunction serializeToken(token: Token): SerializedToken {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name,\n  };\n}\n\nfunction deserializeToken(serializedToken: SerializedToken): Token {\n  return new Token(\n    serializedToken.chainId,\n    serializedToken.address,\n    serializedToken.decimals,\n    serializedToken.symbol,\n    serializedToken.name\n  );\n}\n\nexport function useIsDarkMode(): boolean {\n  const { userDarkMode, matchesDarkMode } = useSelector<\n    AppState,\n    { userDarkMode: boolean | null; matchesDarkMode: boolean }\n  >(\n    ({ user: { matchesDarkMode, userDarkMode } }) => ({\n      userDarkMode,\n      matchesDarkMode,\n    }),\n    shallowEqual\n  );\n\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\n\nexport function useDarkModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const darkMode = useIsDarkMode();\n\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({ userDarkMode: !darkMode }));\n  }, [darkMode, dispatch]);\n\n  return [darkMode, toggleSetDarkMode];\n}\n\nexport function useIsExpertMode(): boolean {\n  return useSelector<AppState, AppState[\"user\"][\"userExpertMode\"]>(\n    (state) => state.user.userExpertMode\n  );\n}\n\nexport function useExpertModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const expertMode = useIsExpertMode();\n\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }));\n  }, [expertMode, dispatch]);\n\n  return [expertMode, toggleSetExpertMode];\n}\n\nexport function useUserSingleHopOnly(): [\n  boolean,\n  (newSingleHopOnly: boolean) => void\n] {\n  const dispatch = useDispatch<AppDispatch>();\n\n  const singleHopOnly = useSelector<\n    AppState,\n    AppState[\"user\"][\"userSingleHopOnly\"]\n  >((state) => state.user.userSingleHopOnly);\n\n  const setSingleHopOnly = useCallback(\n    (newSingleHopOnly: boolean) => {\n      ReactGA.event({\n        category: \"Routing\",\n        action: newSingleHopOnly ? \"enable single hop\" : \"disable single hop\",\n      });\n      dispatch(\n        updateUserSingleHopOnly({ userSingleHopOnly: newSingleHopOnly })\n      );\n    },\n    [dispatch]\n  );\n\n  return [singleHopOnly, setSingleHopOnly];\n}\n\nexport function useUserSlippageTolerance(): [\n  number,\n  (slippage: number) => void\n] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userSlippageTolerance = useSelector<\n    AppState,\n    AppState[\"user\"][\"userSlippageTolerance\"]\n  >((state) => {\n    return state.user.userSlippageTolerance;\n  });\n\n  const setUserSlippageTolerance = useCallback(\n    (userSlippageTolerance: number) => {\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance }));\n    },\n    [dispatch]\n  );\n\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\nexport function useUserTransactionTTL(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userDeadline = useSelector<AppState, AppState[\"user\"][\"userDeadline\"]>(\n    (state) => {\n      return state.user.userDeadline;\n    }\n  );\n\n  const setUserDeadline = useCallback(\n    (userDeadline: number) => {\n      dispatch(updateUserDeadline({ userDeadline }));\n    },\n    [dispatch]\n  );\n\n  return [userDeadline, setUserDeadline];\n}\n\nexport function useAddUserToken(): (token: Token) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (token: Token) => {\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useRemoveUserAddedToken(): (\n  chainId: number,\n  address: string\n) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (chainId: number, address: string) => {\n      dispatch(removeSerializedToken({ chainId, address }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useUserAddedTokens(): Token[] {\n  const { chainId } = useActiveWeb3React();\n  const serializedTokensMap = useSelector<AppState, AppState[\"user\"][\"tokens\"]>(\n    ({ user: { tokens } }) => tokens\n  );\n\n  return useMemo(() => {\n    if (!chainId) return [];\n    return Object.values(serializedTokensMap[chainId as ChainId] ?? {}).map(\n      deserializeToken\n    );\n  }, [serializedTokensMap, chainId]);\n}\n\nfunction serializePair(pair: Pair): SerializedPair {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1),\n  };\n}\n\nexport function usePairAdder(): (pair: Pair) => void {\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (pair: Pair) => {\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useURLWarningVisible(): boolean {\n  return useSelector((state: AppState) => state.user.URLWarningVisible);\n}\n\nexport function useURLWarningToggle(): () => void {\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\n  return new Token(\n    tokenA.chainId,\n    Pair.getAddress(tokenA, tokenB),\n    18,\n    \"UNI-V2\",\n    \"Uniswap V2\"\n  );\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs(): null {\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}