{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { currencyEquals, ETHER, WETH } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { tryParseAmount } from \"../state/swap/hooks\";\nimport { useTransactionAdder } from \"../state/transactions/hooks\";\nimport { useCurrencyBalance } from \"../state/wallet/hooks\";\nimport { useActiveWeb3React } from \"./index\";\nexport let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React(); // const wethContract = useWETHContract()\n\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH`\n            });\n          } catch (error) {\n            console.error(\"Could not deposit\", error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : \"Insufficient ETH balance\"\n      };\n    } else if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${inputAmount.toSignificant(6)} WETH to ETH`\n            });\n          } catch (error) {\n            console.error(\"Could not withdraw\", error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : \"Insufficient WETH balance\"\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}\n\n_s(useWrapCallback, \"W4XV4tOKKVG+7PQCK0YDqhRSkJk=\", false, function () {\n  return [useActiveWeb3React, useCurrencyBalance, useTransactionAdder];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/useWrapCallback.ts"],"names":["currencyEquals","ETHER","WETH","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","balance","undefined","inputAmount","addTransaction","wethContract","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"mappings":"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","sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { tryParseAmount } from \"../state/swap/hooks\";\nimport { useTransactionAdder } from \"../state/transactions/hooks\";\nimport { useCurrencyBalance } from \"../state/wallet/hooks\";\nimport { useActiveWeb3React } from \"./index\";\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  typedValue: string | undefined\n): {\n  wrapType: WrapType;\n  execute?: undefined | (() => Promise<void>);\n  inputError?: string;\n} {\n  const { chainId, account } = useActiveWeb3React();\n  // const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency);\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(\n    () => tryParseAmount(typedValue, inputCurrency),\n    [inputCurrency, typedValue]\n  );\n  const addTransaction = useTransactionAdder();\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency)\n      return NOT_APPLICABLE;\n\n    const sufficientBalance =\n      inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (\n      inputCurrency === ETHER &&\n      currencyEquals(WETH[chainId], outputCurrency)\n    ) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.deposit({\n                    value: `0x${inputAmount.raw.toString(16)}`,\n                  });\n                  addTransaction(txReceipt, {\n                    summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH`,\n                  });\n                } catch (error) {\n                  console.error(\"Could not deposit\", error);\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : \"Insufficient ETH balance\",\n      };\n    } else if (\n      currencyEquals(WETH[chainId], inputCurrency) &&\n      outputCurrency === ETHER\n    ) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(\n                    `0x${inputAmount.raw.toString(16)}`\n                  );\n                  addTransaction(txReceipt, {\n                    summary: `Unwrap ${inputAmount.toSignificant(\n                      6\n                    )} WETH to ETH`,\n                  });\n                } catch (error) {\n                  console.error(\"Could not withdraw\", error);\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : \"Insufficient WETH balance\",\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [\n    wethContract,\n    chainId,\n    inputCurrency,\n    outputCurrency,\n    inputAmount,\n    balance,\n    addTransaction,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}