{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { isTradeBetter } from \"utils/trades\";\nimport { Trade } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { BETTER_TRADE_LESS_HOPS_THRESHOLD } from \"../constants\";\nimport { PairState, usePairs } from \"../data/Reserves\"; // import { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useActiveWeb3React } from \"./index\";\nimport { useUnsupportedTokens } from \"./Tokens\";\nimport { useUserSingleHopOnly } from \"state/user/hooks\";\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React(); // const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n  // const [tokenA, tokenB] = chainId\n  //   ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n  //   : [undefined, undefined]\n  // const basePairs: [Token, Token][] = useMemo(\n  //   () =>\n  //     flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase])).filter(\n  //       ([t0, t1]) => t0.address !== t1.address\n  //     ),\n  //   [bases]\n  // )\n  // const allPairCombinations: [Token, Token][] = useMemo(\n  //   () =>\n  //     tokenA && tokenB\n  //       ? [\n  //           // the direct pair\n  //           [tokenA, tokenB],\n  //           // token A against all bases\n  //           ...bases.map((base): [Token, Token] => [tokenA, base]),\n  //           // token B against all bases\n  //           ...bases.map((base): [Token, Token] => [tokenB, base]),\n  //           // each base against all bases\n  //           ...basePairs\n  //         ]\n  //           .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n  //           .filter(([t0, t1]) => t0.address !== t1.address)\n  //           .filter(([tokenA, tokenB]) => {\n  //             if (!chainId) return true\n  //             // const customBases = CUSTOM_BASES[chainId]\n  //             // if (!customBases) return true\n  //             // const customBasesA: Token[] | undefined = customBases[tokenA.address]\n  //             // const customBasesB: Token[] | undefined = customBases[tokenB.address]\n  //             // if (!customBasesA && !customBasesB) return true\n  //             // if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false\n  //             // if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false\n  //             return true\n  //           })\n  //       : [],\n  //   [tokenA, tokenB, bases, basePairs, chainId]\n  // )\n\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n\n_s(useAllCommonPairs, \"HgW9gWHnh1i2AyL1yWIff4p5/bI=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nconst MAX_HOPS = 3;\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n\n        const currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null; // if current trade is best yet, save it\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n\n_s2(useTradeExactIn, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n\n        const currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n\n_s3(useTradeExactOut, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\n\nexport function useIsTransactionUnsupported(currencyIn, currencyOut) {\n  _s4();\n\n  const unsupportedToken = useUnsupportedTokens();\n  const {\n    chainId\n  } = useActiveWeb3React(); // const tokenIn = wrappedCurrency(currencyIn, chainId)\n  // const tokenOut = wrappedCurrency(currencyOut, chainId)\n  // if unsupported list loaded & either token on list, mark as unsupported\n\n  if (unsupportedToken) {// if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n    //   return true\n    // }\n    // if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n    //   return true\n    // }\n  }\n\n  return false;\n}\n\n_s4(useIsTransactionUnsupported, \"Aar3iA42jY6mFIzqaJt9XWWGpOc=\", false, function () {\n  return [useUnsupportedTokens, useActiveWeb3React];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/Trades.ts"],"names":["isTradeBetter","Trade","useMemo","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","useActiveWeb3React","useUnsupportedTokens","useUserSingleHopOnly","useAllCommonPairs","currencyA","currencyB","chainId","allPairs","allPairCombinations","Object","values","filter","result","Boolean","EXISTS","reduce","memo","curr","liquidityToken","address","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut","useIsTransactionUnsupported","unsupportedToken"],"mappings":"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","sourcesContent":["import { isTradeBetter } from \"utils/trades\";\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from \"@uniswap/sdk\";\nimport flatMap from \"lodash.flatmap\";\nimport { useMemo } from \"react\";\n\nimport { BETTER_TRADE_LESS_HOPS_THRESHOLD } from \"../constants\";\nimport { PairState, usePairs } from \"../data/Reserves\";\n// import { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useActiveWeb3React } from \"./index\";\nimport { useUnsupportedTokens } from \"./Tokens\";\nimport { useUserSingleHopOnly } from \"state/user/hooks\";\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React();\n\n  // const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n\n  // const [tokenA, tokenB] = chainId\n  //   ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n  //   : [undefined, undefined]\n\n  // const basePairs: [Token, Token][] = useMemo(\n  //   () =>\n  //     flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase])).filter(\n  //       ([t0, t1]) => t0.address !== t1.address\n  //     ),\n  //   [bases]\n  // )\n\n  // const allPairCombinations: [Token, Token][] = useMemo(\n  //   () =>\n  //     tokenA && tokenB\n  //       ? [\n  //           // the direct pair\n  //           [tokenA, tokenB],\n  //           // token A against all bases\n  //           ...bases.map((base): [Token, Token] => [tokenA, base]),\n  //           // token B against all bases\n  //           ...bases.map((base): [Token, Token] => [tokenB, base]),\n  //           // each base against all bases\n  //           ...basePairs\n  //         ]\n  //           .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n  //           .filter(([t0, t1]) => t0.address !== t1.address)\n  //           .filter(([tokenA, tokenB]) => {\n  //             if (!chainId) return true\n  //             // const customBases = CUSTOM_BASES[chainId]\n  //             // if (!customBases) return true\n\n  //             // const customBasesA: Token[] | undefined = customBases[tokenA.address]\n  //             // const customBasesB: Token[] | undefined = customBases[tokenB.address]\n\n  //             // if (!customBasesA && !customBasesB) return true\n\n  //             // if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false\n  //             // if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false\n\n  //             return true\n  //           })\n  //       : [],\n  //   [tokenA, tokenB, bases, basePairs, chainId]\n  // )\n\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] =>\n            Boolean(result[0] === PairState.EXISTS && result[1])\n          )\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] =\n              memo[curr.liquidityToken.address] ?? curr;\n            return memo;\n          }, {})\n      ),\n    [allPairs]\n  );\n}\n\nconst MAX_HOPS = 3;\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(\n  currencyAmountIn?: CurrencyAmount,\n  currencyOut?: Currency\n): Trade | null {\n  const allowedPairs = useAllCommonPairs(\n    currencyAmountIn?.currency,\n    currencyOut\n  );\n\n  const [singleHopOnly] = useUserSingleHopOnly();\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n            maxHops: 1,\n            maxNumResults: 1,\n          })[0] ?? null\n        );\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n            maxHops: i,\n            maxNumResults: 1,\n          })[0] ?? null;\n        // if current trade is best yet, save it\n        if (\n          isTradeBetter(\n            bestTradeSoFar,\n            currentTrade,\n            BETTER_TRADE_LESS_HOPS_THRESHOLD\n          )\n        ) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(\n  currencyIn?: Currency,\n  currencyAmountOut?: CurrencyAmount\n): Trade | null {\n  const allowedPairs = useAllCommonPairs(\n    currencyIn,\n    currencyAmountOut?.currency\n  );\n\n  const [singleHopOnly] = useUserSingleHopOnly();\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n            maxHops: 1,\n            maxNumResults: 1,\n          })[0] ?? null\n        );\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n            maxHops: i,\n            maxNumResults: 1,\n          })[0] ?? null;\n        if (\n          isTradeBetter(\n            bestTradeSoFar,\n            currentTrade,\n            BETTER_TRADE_LESS_HOPS_THRESHOLD\n          )\n        ) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n\nexport function useIsTransactionUnsupported(\n  currencyIn?: Currency,\n  currencyOut?: Currency\n): boolean {\n  const unsupportedToken: { [address: string]: Token } = useUnsupportedTokens();\n  const { chainId } = useActiveWeb3React();\n\n  // const tokenIn = wrappedCurrency(currencyIn, chainId)\n  // const tokenOut = wrappedCurrency(currencyOut, chainId)\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedToken) {\n    // if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n    //   return true\n    // }\n    // if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n    //   return true\n    // }\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}