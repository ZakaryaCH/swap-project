{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from \"react\";\nimport { useAllTokenBalances } from \"../../state/wallet/hooks\";\n\n// compare two token amounts with highest one coming first\nfunction balanceComparator(balanceA, balanceB) {\n  if (balanceA && balanceB) {\n    return balanceA.greaterbalanceThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1;\n  } else if (balanceA && balanceA.greaterThan(\"0\")) {\n    return -1;\n  } else if (balanceB && balanceB.greaterThan(\"0\")) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction getTokenComparator(balances) {\n  return function sortTokens(tokenA, tokenB) {\n    // -1 = a is first\n    // 1 = b is first\n    // sort by balances\n    const balanceA = balances[tokenA.address];\n    const balanceB = balances[tokenB.address];\n    const balanceComp = balanceComparator(balanceA, balanceB);\n    if (balanceComp !== 0) return balanceComp;\n\n    if (tokenA.symbol && tokenB.symbol) {\n      // sort by symbol\n      return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;\n    } else {\n      return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;\n    }\n  };\n}\n\nexport function useTokenComparator(inverted) {\n  _s();\n\n  const balances = useAllTokenBalances();\n  const comparator = useMemo(() => getTokenComparator(balances !== null && balances !== void 0 ? balances : {}), [balances]);\n  return useMemo(() => {\n    if (inverted) {\n      return (tokenA, tokenB) => comparator(tokenA, tokenB) * -1;\n    } else {\n      return comparator;\n    }\n  }, [inverted, comparator]);\n}\n\n_s(useTokenComparator, \"hXJEt3u0yPW0rBCA9PpnEAzwUpI=\", false, function () {\n  return [useAllTokenBalances];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/components/SearchModal/sorting.ts"],"names":["useMemo","useAllTokenBalances","balanceComparator","balanceA","balanceB","greaterbalanceThan","equalTo","greaterThan","getTokenComparator","balances","sortTokens","tokenA","tokenB","address","balanceComp","symbol","toLowerCase","useTokenComparator","inverted","comparator"],"mappings":";;AACA,SAASA,OAAT,QAAwB,OAAxB;AACA,SAASC,mBAAT,QAAoC,0BAApC;;AAGA;AACA,SAASC,iBAAT,CAA2BC,QAA3B,EAAmDC,QAAnD,EAA2E;AACzE,MAAID,QAAQ,IAAIC,QAAhB,EAA0B;AACxB,WAAOD,QAAQ,CAACE,kBAAT,CAA4BD,QAA5B,IACH,CAAC,CADE,GAEHD,QAAQ,CAACG,OAAT,CAAiBF,QAAjB,IACA,CADA,GAEA,CAJJ;AAKD,GAND,MAMO,IAAID,QAAQ,IAAIA,QAAQ,CAACI,WAAT,CAAqB,GAArB,CAAhB,EAA2C;AAChD,WAAO,CAAC,CAAR;AACD,GAFM,MAEA,IAAIH,QAAQ,IAAIA,QAAQ,CAACG,WAAT,CAAqB,GAArB,CAAhB,EAA2C;AAChD,WAAO,CAAP;AACD;;AACD,SAAO,CAAP;AACD;;AAED,SAASC,kBAAT,CAA4BC,QAA5B,EAE6C;AAC3C,SAAO,SAASC,UAAT,CAAoBC,MAApB,EAAmCC,MAAnC,EAA0D;AAC/D;AACA;AAEA;AACA,UAAMT,QAAQ,GAAGM,QAAQ,CAACE,MAAM,CAACE,OAAR,CAAzB;AACA,UAAMT,QAAQ,GAAGK,QAAQ,CAACG,MAAM,CAACC,OAAR,CAAzB;AAEA,UAAMC,WAAW,GAAGZ,iBAAiB,CAACC,QAAD,EAAWC,QAAX,CAArC;AACA,QAAIU,WAAW,KAAK,CAApB,EAAuB,OAAOA,WAAP;;AAEvB,QAAIH,MAAM,CAACI,MAAP,IAAiBH,MAAM,CAACG,MAA5B,EAAoC;AAClC;AACA,aAAOJ,MAAM,CAACI,MAAP,CAAcC,WAAd,KAA8BJ,MAAM,CAACG,MAAP,CAAcC,WAAd,EAA9B,GAA4D,CAAC,CAA7D,GAAiE,CAAxE;AACD,KAHD,MAGO;AACL,aAAOL,MAAM,CAACI,MAAP,GAAgB,CAAC,CAAjB,GAAqBH,MAAM,CAACG,MAAP,GAAgB,CAAC,CAAjB,GAAqB,CAAjD;AACD;AACF,GAjBD;AAkBD;;AAED,OAAO,SAASE,kBAAT,CACLC,QADK,EAEqC;AAAA;;AAC1C,QAAMT,QAAQ,GAAGR,mBAAmB,EAApC;AACA,QAAMkB,UAAU,GAAGnB,OAAO,CACxB,MAAMQ,kBAAkB,CAACC,QAAD,aAACA,QAAD,cAACA,QAAD,GAAa,EAAb,CADA,EAExB,CAACA,QAAD,CAFwB,CAA1B;AAIA,SAAOT,OAAO,CAAC,MAAM;AACnB,QAAIkB,QAAJ,EAAc;AACZ,aAAO,CAACP,MAAD,EAAgBC,MAAhB,KAAkCO,UAAU,CAACR,MAAD,EAASC,MAAT,CAAV,GAA6B,CAAC,CAAvE;AACD,KAFD,MAEO;AACL,aAAOO,UAAP;AACD;AACF,GANa,EAMX,CAACD,QAAD,EAAWC,UAAX,CANW,CAAd;AAOD;;GAfeF,kB;UAGGhB,mB","sourcesContent":["import { TokenAmount } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { useAllTokenBalances } from \"../../state/wallet/hooks\";\nimport { Token } from \"../../types\";\n\n// compare two token amounts with highest one coming first\nfunction balanceComparator(balanceA?: TokenAmount, balanceB?: TokenAmount) {\n  if (balanceA && balanceB) {\n    return balanceA.greaterbalanceThan(balanceB)\n      ? -1\n      : balanceA.equalTo(balanceB)\n      ? 0\n      : 1;\n  } else if (balanceA && balanceA.greaterThan(\"0\")) {\n    return -1;\n  } else if (balanceB && balanceB.greaterThan(\"0\")) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction getTokenComparator(balances: {\n  [tokenAddress: string]: TokenAmount | undefined;\n}): (tokenA: Token, tokenB: Token) => number {\n  return function sortTokens(tokenA: Token, tokenB: Token): number {\n    // -1 = a is first\n    // 1 = b is first\n\n    // sort by balances\n    const balanceA = balances[tokenA.address];\n    const balanceB = balances[tokenB.address];\n\n    const balanceComp = balanceComparator(balanceA, balanceB);\n    if (balanceComp !== 0) return balanceComp;\n\n    if (tokenA.symbol && tokenB.symbol) {\n      // sort by symbol\n      return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;\n    } else {\n      return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;\n    }\n  };\n}\n\nexport function useTokenComparator(\n  inverted: boolean\n): (tokenA: Token, tokenB: Token) => number {\n  const balances = useAllTokenBalances();\n  const comparator = useMemo(\n    () => getTokenComparator(balances ?? {}),\n    [balances]\n  );\n  return useMemo(() => {\n    if (inverted) {\n      return (tokenA: Token, tokenB: Token) => comparator(tokenA, tokenB) * -1;\n    } else {\n      return comparator;\n    }\n  }, [inverted, comparator]);\n}\n"]},"metadata":{},"sourceType":"module"}