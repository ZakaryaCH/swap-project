{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$();\n\nimport { useUnsupportedTokenList } from \"./../state/lists/hooks\";\nimport { parseBytes32String } from \"@ethersproject/strings\";\nimport { ETHER, Token, currencyEquals } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { useCombinedInactiveList } from \"../state/lists/hooks\";\nimport { NEVER_RELOAD, useSingleCallResult } from \"../state/multicall/hooks\"; // import { useUserAddedTokens } from \"../state/user/hooks\";\n\nimport { isAddress } from \"../utils\";\nimport { useActiveWeb3React } from \"./index\";\nimport { useBytes32TokenContract, useTokenContract } from \"./useContract\";\nimport { filterTokens } from \"../components/SearchModal/filtering\";\nimport { arrayify } from \"ethers/lib/utils\"; // reduce token map into standard address <-> Token mapping, optionally include user added tokens\n// function useTokensFromMap(\n//   tokenMap: TokenAddressMap,\n//   includeUserAdded: boolean\n// ): { [address: string]: Token } {\n//   const { chainId } = useActiveWeb3React();\n//   // const userAddedTokens = useUserAddedTokens();\n//   return useMemo(() => {\n//     if (!chainId) return {};\n//     // reduce to just tokens\n//     const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce<{\n//       [address: string]: Token;\n//     }>((newMap, address) => {\n//       newMap[address] = tokenMap[chainId][address].token;\n//       return newMap;\n//     }, {});\n//     if (includeUserAdded) {\n//       return (\n//         userAddedTokens\n//           // reduce into all ALL_TOKENS filtered by the current chain\n//           .reduce<{ [address: string]: Token }>(\n//             (tokenMap, token) => {\n//               tokenMap[token.address] = token;\n//               return tokenMap;\n//             },\n//             // must make a copy because reduce modifies the map, and we do not\n//             // want to make a copy in every iteration\n//             { ...mapWithoutUrls }\n//           )\n//       );\n//     }\n//     return mapWithoutUrls;\n//   }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n// }\n\nexport function useDefaultTokens() {\n  // const defaultList = useDefaultTokenList();\n  // return useTokensFromMap(defaultList, false);\n  return null;\n}\nexport function useAllTokens() {\n  // const allTokens = useCombinedActiveList();\n  // return useTokensFromMap(allTokens, true);\n  return null;\n}\nexport function useAllInactiveTokens() {\n  _s();\n\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false); // filter out any token that are on active list\n\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses ? Object.keys(inactiveTokens).reduce((newMap, address) => {\n    if (!activeTokensAddresses.includes(address)) {\n      newMap[address] = inactiveTokens[address];\n    }\n\n    return newMap;\n  }, {}) : inactiveTokens;\n  return filteredInactive;\n}\n\n_s(useAllInactiveTokens, \"y9223uP8GCC/3ME2n383kLmFOz4=\", true, function () {\n  return [useCombinedInactiveList, useAllTokens];\n});\n\nexport function useUnsupportedTokens() {\n  _s2();\n\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  return useTokensFromMap(unsupportedTokensMap, false);\n}\n\n_s2(useUnsupportedTokens, \"cfUcH2/tU9tFbaAvFr6x9maL1ms=\", true, function () {\n  return [useUnsupportedTokenList];\n});\n\nexport function useIsTokenActive(token) {\n  _s3();\n\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n} // used to detect extra search results\n\n_s3(useIsTokenActive, \"/DZnqUeqi963rU8m84lshLFLG1g=\", false, function () {\n  return [useAllTokens];\n});\n\nexport function useFoundOnInactiveList(searchQuery) {\n  _s4();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n  return useMemo(() => {\n    if (!chainId || searchQuery === \"\") {\n      return undefined;\n    } else {\n      const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n      return tokens;\n    }\n  }, [chainId, inactiveTokens, searchQuery]);\n} // Check if currency is included in custom list from user storage\n\n_s4(useFoundOnInactiveList, \"hwNPd01dv/ucAD4kWZcYbreBqQU=\", false, function () {\n  return [useActiveWeb3React, useAllInactiveTokens];\n});\n\nexport function useIsUserAddedToken(currency) {\n  _s5();\n\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n} // parse a name or symbol from a token response\n\n_s5(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", true);\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  _s6();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, \"name\", undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, \"name\", undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, \"symbol\", undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, \"symbol\", undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, \"decimals\", undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], \"UNKNOWN\"), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], \"Unknown Token\"));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\n\n_s6(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n\nexport function useCurrency(currencyId) {\n  _s7();\n\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === \"ETH\";\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n\n_s7(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/Tokens.ts"],"names":["useUnsupportedTokenList","parseBytes32String","ETHER","Token","currencyEquals","useMemo","useCombinedInactiveList","NEVER_RELOAD","useSingleCallResult","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","filterTokens","arrayify","useDefaultTokens","useAllTokens","useAllInactiveTokens","inactiveTokensMap","inactiveTokens","useTokensFromMap","activeTokensAddresses","Object","keys","filteredInactive","reduce","newMap","address","includes","useUnsupportedTokens","unsupportedTokensMap","useIsTokenActive","token","activeTokens","useFoundOnInactiveList","searchQuery","chainId","undefined","tokens","values","useIsUserAddedToken","currency","userAddedTokens","useUserAddedTokens","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokenContract","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useCurrency","currencyId","isETH","toUpperCase"],"mappings":"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","sourcesContent":["import {\n  TokenAddressMap,\n  useDefaultTokenList,\n  useUnsupportedTokenList,\n} from \"./../state/lists/hooks\";\nimport { parseBytes32String } from \"@ethersproject/strings\";\nimport { Currency, ETHER, Token, currencyEquals } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport {\n  useCombinedActiveList,\n  useCombinedInactiveList,\n} from \"../state/lists/hooks\";\nimport { NEVER_RELOAD, useSingleCallResult } from \"../state/multicall/hooks\";\n// import { useUserAddedTokens } from \"../state/user/hooks\";\nimport { isAddress } from \"../utils\";\n\nimport { useActiveWeb3React } from \"./index\";\nimport { useBytes32TokenContract, useTokenContract } from \"./useContract\";\nimport { filterTokens } from \"../components/SearchModal/filtering\";\nimport { arrayify } from \"ethers/lib/utils\";\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\n// function useTokensFromMap(\n//   tokenMap: TokenAddressMap,\n//   includeUserAdded: boolean\n// ): { [address: string]: Token } {\n//   const { chainId } = useActiveWeb3React();\n//   // const userAddedTokens = useUserAddedTokens();\n\n//   return useMemo(() => {\n//     if (!chainId) return {};\n\n//     // reduce to just tokens\n//     const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce<{\n//       [address: string]: Token;\n//     }>((newMap, address) => {\n//       newMap[address] = tokenMap[chainId][address].token;\n//       return newMap;\n//     }, {});\n\n//     if (includeUserAdded) {\n//       return (\n//         userAddedTokens\n//           // reduce into all ALL_TOKENS filtered by the current chain\n//           .reduce<{ [address: string]: Token }>(\n//             (tokenMap, token) => {\n//               tokenMap[token.address] = token;\n//               return tokenMap;\n//             },\n//             // must make a copy because reduce modifies the map, and we do not\n//             // want to make a copy in every iteration\n//             { ...mapWithoutUrls }\n//           )\n//       );\n//     }\n\n//     return mapWithoutUrls;\n//   }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n// }\n\nexport function useDefaultTokens(): null {\n  // const defaultList = useDefaultTokenList();\n  // return useTokensFromMap(defaultList, false);\n  return null;\n}\n\nexport function useAllTokens(): { [address: string]: null } {\n  // const allTokens = useCombinedActiveList();\n  // return useTokensFromMap(allTokens, true);\n  return null;\n}\n\nexport function useAllInactiveTokens(): { [address: string]: Token } {\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false);\n\n  // filter out any token that are on active list\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses\n    ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>(\n        (newMap, address) => {\n          if (!activeTokensAddresses.includes(address)) {\n            newMap[address] = inactiveTokens[address];\n          }\n          return newMap;\n        },\n        {}\n      )\n    : inactiveTokens;\n\n  return filteredInactive;\n}\n\nexport function useUnsupportedTokens(): { [address: string]: Token } {\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  return useTokensFromMap(unsupportedTokensMap, false);\n}\n\nexport function useIsTokenActive(token: Token | undefined | null): boolean {\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n}\n\n// used to detect extra search results\nexport function useFoundOnInactiveList(\n  searchQuery: string\n): Token[] | undefined {\n  const { chainId } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n\n  return useMemo(() => {\n    if (!chainId || searchQuery === \"\") {\n      return undefined;\n    } else {\n      const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n      return tokens;\n    }\n  }, [chainId, inactiveTokens, searchQuery]);\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(\n  currency: Currency | undefined | null\n): boolean {\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token));\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(\n  str: string | undefined,\n  bytes32: string | undefined,\n  defaultValue: string\n): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  const address = isAddress(tokenAddress);\n\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(\n    address ? address : undefined,\n    false\n  );\n  const token: Token | undefined = address ? tokens[address] : undefined;\n\n  const tokenName = useSingleCallResult(\n    token ? undefined : tokenContract,\n    \"name\",\n    undefined,\n    NEVER_RELOAD\n  );\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    \"name\",\n    undefined,\n    NEVER_RELOAD\n  );\n  const symbol = useSingleCallResult(\n    token ? undefined : tokenContract,\n    \"symbol\",\n    undefined,\n    NEVER_RELOAD\n  );\n  const symbolBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    \"symbol\",\n    undefined,\n    NEVER_RELOAD\n  );\n  const decimals = useSingleCallResult(\n    token ? undefined : tokenContract,\n    \"decimals\",\n    undefined,\n    NEVER_RELOAD\n  );\n\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(\n          symbol.result?.[0],\n          symbolBytes32.result?.[0],\n          \"UNKNOWN\"\n        ),\n        parseStringOrBytes32(\n          tokenName.result?.[0],\n          tokenNameBytes32.result?.[0],\n          \"Unknown Token\"\n        )\n      );\n    }\n    return undefined;\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result,\n  ]);\n}\n\nexport function useCurrency(\n  currencyId: string | undefined\n): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === \"ETH\";\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n"]},"metadata":{},"sourceType":"module"}