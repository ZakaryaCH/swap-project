{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { parseBytes32String } from \"@ethersproject/strings\";\nimport { ETHER } from \"@uniswap/sdk\";\nimport { arrayify } from \"ethers/lib/utils\";\nimport { useQuery } from \"react-query\";\nimport getTokenList from \"utils/getTokenList\"; // reduce token map into standard address <-> Token mapping, optionally include user added tokens\n// function useTokensFromMap(\n//   tokenMap: TokenAddressMap,\n//   includeUserAdded: boolean\n// ): { [address: string]: Token } {\n//   const { chainId } = useActiveWeb3React();\n//   // const userAddedTokens = useUserAddedTokens();\n//   return useMemo(() => {\n//     if (!chainId) return {};\n//     // reduce to just tokens\n//     const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce<{\n//       [address: string]: Token;\n//     }>((newMap, address) => {\n//       newMap[address] = tokenMap[chainId][address].token;\n//       return newMap;\n//     }, {});\n//     if (includeUserAdded) {\n//       return (\n//         userAddedTokens\n//           // reduce into all ALL_TOKENS filtered by the current chain\n//           .reduce<{ [address: string]: Token }>(\n//             (tokenMap, token) => {\n//               tokenMap[token.address] = token;\n//               return tokenMap;\n//             },\n//             // must make a copy because reduce modifies the map, and we do not\n//             // want to make a copy in every iteration\n//             { ...mapWithoutUrls }\n//           )\n//       );\n//     }\n//     return mapWithoutUrls;\n//   }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n// }\n\nexport function useDefaultTokens() {\n  // const defaultList = useDefaultTokenList();\n  // return useTokensFromMap(defaultList, false);\n  return null;\n}\nexport function useAllTokens() {\n  _s();\n\n  const query = useQuery(\"tokenList\", getTokenList); // const allTokens = useCombinedActiveList();\n  // return useTokensFromMap(allTokens, true);\n\n  return query;\n}\n\n_s(useAllTokens, \"c7fxJWDO4uMGjIdKMJSj1aiS9wg=\", false, function () {\n  return [useQuery];\n});\n\nexport function useAllInactiveTokens() {\n  // get inactive tokens\n  // const inactiveTokensMap = useCombinedInactiveList();\n  // const inactiveTokens = useTokensFromMap(inactiveTokensMap, false);\n  // // filter out any token that are on active list\n  // const activeTokensAddresses = Object.keys(useAllTokens());\n  // const filteredInactive = activeTokensAddresses\n  //   ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>(\n  //       (newMap, address) => {\n  //         if (!activeTokensAddresses.includes(address)) {\n  //           newMap[address] = inactiveTokens[address];\n  //         }\n  //         return newMap;\n  //       },\n  //       {}\n  //     )\n  //   : inactiveTokens;\n  // return filteredInactive;\n  return null;\n}\nexport function useUnsupportedTokens() {\n  // const unsupportedTokensMap = useUnsupportedTokenList();\n  // return useTokensFromMap(unsupportedTokensMap, false);\n  return null;\n}\nexport function useIsTokenActive(token) {\n  // const activeTokens = useAllTokens();\n  // if (!activeTokens || !token) {\n  //   return false;\n  // }\n  // return !!activeTokens[token.address];\n  return null;\n} // used to detect extra search results\n\nexport function useFoundOnInactiveList(searchQuery) {\n  // const { chainId } = useActiveWeb3React();\n  // const inactiveTokens = useAllInactiveTokens();\n  // return useMemo(() => {\n  //   if (!chainId || searchQuery === \"\") {\n  //     return undefined;\n  //   } else {\n  //     const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n  //     return tokens;\n  //   }\n  // }, [chainId, inactiveTokens, searchQuery]);\n  return null;\n} // Check if currency is included in custom list from user storage\n\nexport function useIsUserAddedToken(currency) {\n  // const userAddedTokens = useUserAddedTokens();\n  // if (!currency) {\n  //   return false;\n  // }\n  // return !!userAddedTokens.find((token) => currencyEquals(currency, token));\n  return null;\n} // parse a name or symbol from a token response\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  // const { chainId } = useActiveWeb3React();\n  // const tokens = useAllTokens();\n  // const address = isAddress(tokenAddress);\n  // const tokenContract = useTokenContract(address ? address : undefined, false);\n  // const tokenContractBytes32 = useBytes32TokenContract(\n  //   address ? address : undefined,\n  //   false\n  // );\n  // const token: Token | undefined = address ? tokens[address] : undefined;\n  // const tokenName = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"name\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const tokenNameBytes32 = useSingleCallResult(\n  //   token ? undefined : tokenContractBytes32,\n  //   \"name\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const symbol = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"symbol\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const symbolBytes32 = useSingleCallResult(\n  //   token ? undefined : tokenContractBytes32,\n  //   \"symbol\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const decimals = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"decimals\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // return useMemo(() => {\n  //   if (token) return token;\n  //   if (!chainId || !address) return undefined;\n  //   if (decimals.loading || symbol.loading || tokenName.loading) return null;\n  //   if (decimals.result) {\n  //     return new Token(\n  //       chainId,\n  //       address,\n  //       decimals.result[0],\n  //       parseStringOrBytes32(\n  //         symbol.result?.[0],\n  //         symbolBytes32.result?.[0],\n  //         \"UNKNOWN\"\n  //       ),\n  //       parseStringOrBytes32(\n  //         tokenName.result?.[0],\n  //         tokenNameBytes32.result?.[0],\n  //         \"Unknown Token\"\n  //       )\n  //     );\n  //   }\n  //   return undefined;\n  // }, [\n  //   address,\n  //   chainId,\n  //   decimals.loading,\n  //   decimals.result,\n  //   symbol.loading,\n  //   symbol.result,\n  //   symbolBytes32.result,\n  //   token,\n  //   tokenName.loading,\n  //   tokenName.result,\n  //   tokenNameBytes32.result,\n  // ]);\n  return null;\n}\nexport function useCurrency(currencyId) {\n  _s2();\n\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === \"ETH\";\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n\n_s2(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/Tokens.ts"],"names":["parseBytes32String","ETHER","arrayify","useQuery","getTokenList","useDefaultTokens","useAllTokens","query","useAllInactiveTokens","useUnsupportedTokens","useIsTokenActive","token","useFoundOnInactiveList","searchQuery","useIsUserAddedToken","currency","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","useCurrency","currencyId","isETH","toUpperCase","undefined"],"mappings":";;;AAKA,SAASA,kBAAT,QAAmC,wBAAnC;AACA,SAAmBC,KAAnB,QAAuD,cAAvD;AAaA,SAASC,QAAT,QAAyB,kBAAzB;AACA,SAASC,QAAT,QAAyC,aAAzC;AACA,OAAOC,YAAP,MAAyB,oBAAzB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA,OAAO,SAASC,gBAAT,GAAkC;AACvC;AACA;AACA,SAAO,IAAP;AACD;AAED,OAAO,SAASC,YAAT,GAAsD;AAAA;;AAC3D,QAAMC,KAAK,GAAGJ,QAAQ,CAAC,WAAD,EAAcC,YAAd,CAAtB,CAD2D,CAG3D;AACA;;AACA,SAAOG,KAAP;AACD;;GANeD,Y;UACAH,Q;;;AAOhB,OAAO,SAASK,oBAAT,GAAsC;AAC3C;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,SAAO,IAAP;AACD;AAED,OAAO,SAASC,oBAAT,GAAsC;AAC3C;AACA;AACA,SAAO,IAAP;AACD;AAED,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAAiE;AACtE;AAEA;AACA;AACA;AAEA;AACA,SAAO,IAAP;AACD,C,CAED;;AACA,OAAO,SAASC,sBAAT,CAAgCC,WAAhC,EAA2D;AAChE;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAO,IAAP;AACD,C,CAED;;AACA,OAAO,SAASC,mBAAT,CACLC,QADK,EAEC;AACN;AAEA;AACA;AACA;AAEA;AACA,SAAO,IAAP;AACD,C,CAED;;AACA,MAAMC,aAAa,GAAG,qBAAtB;;AAEA,SAASC,oBAAT,CACEC,GADF,EAEEC,OAFF,EAGEC,YAHF,EAIU;AACR,SAAOF,GAAG,IAAIA,GAAG,CAACG,MAAJ,GAAa,CAApB,GACHH,GADG,GAEH;AACFC,EAAAA,OAAO,IAAIH,aAAa,CAACM,IAAd,CAAmBH,OAAnB,CAAX,IAA0CjB,QAAQ,CAACiB,OAAD,CAAR,CAAkB,EAAlB,MAA0B,CAApE,GACEnB,kBAAkB,CAACmB,OAAD,CADpB,GAEEC,YALJ;AAMD,C,CAED;AACA;AACA;;;AACA,OAAO,SAASG,QAAT,CAAkBC,YAAlB,EAA+C;AACpD;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAO,IAAP;AACD;AAED,OAAO,SAASC,WAAT,CACLC,UADK,EAEwB;AAAA;;AAC7B,QAAMC,KAAK,GAAG,CAAAD,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAEE,WAAZ,QAA8B,KAA5C;AACA,QAAMjB,KAAK,GAAGY,QAAQ,CAACI,KAAK,GAAGE,SAAH,GAAeH,UAArB,CAAtB;AACA,SAAOC,KAAK,GAAG1B,KAAH,GAAWU,KAAvB;AACD;;IANec,W;UAIAF,Q","sourcesContent":["import {\n  TokenAddressMap,\n  useDefaultTokenList,\n  useUnsupportedTokenList,\n} from \"./../state/lists/hooks\";\nimport { parseBytes32String } from \"@ethersproject/strings\";\nimport { Currency, ETHER, Token, currencyEquals } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport {\n  useCombinedActiveList,\n  useCombinedInactiveList,\n} from \"../state/lists/hooks\";\nimport { NEVER_RELOAD, useSingleCallResult } from \"../state/multicall/hooks\";\n// import { useUserAddedTokens } from \"../state/user/hooks\";\nimport { isAddress } from \"../utils\";\n\nimport { useActiveWeb3React } from \"./index\";\nimport { useBytes32TokenContract, useTokenContract } from \"./useContract\";\nimport { filterTokens } from \"../components/SearchModal/filtering\";\nimport { arrayify } from \"ethers/lib/utils\";\nimport { useQuery, UseQueryResult } from \"react-query\";\nimport getTokenList from \"utils/getTokenList\";\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\n// function useTokensFromMap(\n//   tokenMap: TokenAddressMap,\n//   includeUserAdded: boolean\n// ): { [address: string]: Token } {\n//   const { chainId } = useActiveWeb3React();\n//   // const userAddedTokens = useUserAddedTokens();\n\n//   return useMemo(() => {\n//     if (!chainId) return {};\n\n//     // reduce to just tokens\n//     const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce<{\n//       [address: string]: Token;\n//     }>((newMap, address) => {\n//       newMap[address] = tokenMap[chainId][address].token;\n//       return newMap;\n//     }, {});\n\n//     if (includeUserAdded) {\n//       return (\n//         userAddedTokens\n//           // reduce into all ALL_TOKENS filtered by the current chain\n//           .reduce<{ [address: string]: Token }>(\n//             (tokenMap, token) => {\n//               tokenMap[token.address] = token;\n//               return tokenMap;\n//             },\n//             // must make a copy because reduce modifies the map, and we do not\n//             // want to make a copy in every iteration\n//             { ...mapWithoutUrls }\n//           )\n//       );\n//     }\n\n//     return mapWithoutUrls;\n//   }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n// }\n\nexport function useDefaultTokens(): null {\n  // const defaultList = useDefaultTokenList();\n  // return useTokensFromMap(defaultList, false);\n  return null;\n}\n\nexport function useAllTokens(): UseQueryResult<any, unknown> {\n  const query = useQuery(\"tokenList\", getTokenList);\n\n  // const allTokens = useCombinedActiveList();\n  // return useTokensFromMap(allTokens, true);\n  return query;\n}\n\nexport function useAllInactiveTokens(): null {\n  // get inactive tokens\n  // const inactiveTokensMap = useCombinedInactiveList();\n  // const inactiveTokens = useTokensFromMap(inactiveTokensMap, false);\n\n  // // filter out any token that are on active list\n  // const activeTokensAddresses = Object.keys(useAllTokens());\n  // const filteredInactive = activeTokensAddresses\n  //   ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>(\n  //       (newMap, address) => {\n  //         if (!activeTokensAddresses.includes(address)) {\n  //           newMap[address] = inactiveTokens[address];\n  //         }\n  //         return newMap;\n  //       },\n  //       {}\n  //     )\n  //   : inactiveTokens;\n\n  // return filteredInactive;\n  return null;\n}\n\nexport function useUnsupportedTokens(): null {\n  // const unsupportedTokensMap = useUnsupportedTokenList();\n  // return useTokensFromMap(unsupportedTokensMap, false);\n  return null;\n}\n\nexport function useIsTokenActive(token: Token | undefined | null): null {\n  // const activeTokens = useAllTokens();\n\n  // if (!activeTokens || !token) {\n  //   return false;\n  // }\n\n  // return !!activeTokens[token.address];\n  return null;\n}\n\n// used to detect extra search results\nexport function useFoundOnInactiveList(searchQuery: string): null {\n  // const { chainId } = useActiveWeb3React();\n  // const inactiveTokens = useAllInactiveTokens();\n\n  // return useMemo(() => {\n  //   if (!chainId || searchQuery === \"\") {\n  //     return undefined;\n  //   } else {\n  //     const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n  //     return tokens;\n  //   }\n  // }, [chainId, inactiveTokens, searchQuery]);\n  return null;\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(\n  currency: Currency | undefined | null\n): null {\n  // const userAddedTokens = useUserAddedTokens();\n\n  // if (!currency) {\n  //   return false;\n  // }\n\n  // return !!userAddedTokens.find((token) => currencyEquals(currency, token));\n  return null;\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(\n  str: string | undefined,\n  bytes32: string | undefined,\n  defaultValue: string\n): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): null {\n  // const { chainId } = useActiveWeb3React();\n  // const tokens = useAllTokens();\n\n  // const address = isAddress(tokenAddress);\n\n  // const tokenContract = useTokenContract(address ? address : undefined, false);\n  // const tokenContractBytes32 = useBytes32TokenContract(\n  //   address ? address : undefined,\n  //   false\n  // );\n  // const token: Token | undefined = address ? tokens[address] : undefined;\n\n  // const tokenName = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"name\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const tokenNameBytes32 = useSingleCallResult(\n  //   token ? undefined : tokenContractBytes32,\n  //   \"name\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const symbol = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"symbol\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const symbolBytes32 = useSingleCallResult(\n  //   token ? undefined : tokenContractBytes32,\n  //   \"symbol\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n  // const decimals = useSingleCallResult(\n  //   token ? undefined : tokenContract,\n  //   \"decimals\",\n  //   undefined,\n  //   NEVER_RELOAD\n  // );\n\n  // return useMemo(() => {\n  //   if (token) return token;\n  //   if (!chainId || !address) return undefined;\n  //   if (decimals.loading || symbol.loading || tokenName.loading) return null;\n  //   if (decimals.result) {\n  //     return new Token(\n  //       chainId,\n  //       address,\n  //       decimals.result[0],\n  //       parseStringOrBytes32(\n  //         symbol.result?.[0],\n  //         symbolBytes32.result?.[0],\n  //         \"UNKNOWN\"\n  //       ),\n  //       parseStringOrBytes32(\n  //         tokenName.result?.[0],\n  //         tokenNameBytes32.result?.[0],\n  //         \"Unknown Token\"\n  //       )\n  //     );\n  //   }\n  //   return undefined;\n  // }, [\n  //   address,\n  //   chainId,\n  //   decimals.loading,\n  //   decimals.result,\n  //   symbol.loading,\n  //   symbol.result,\n  //   symbolBytes32.result,\n  //   token,\n  //   tokenName.loading,\n  //   tokenName.result,\n  //   tokenNameBytes32.result,\n  // ]);\n\n  return null;\n}\n\nexport function useCurrency(\n  currencyId: string | undefined\n): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === \"ETH\";\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n"]},"metadata":{},"sourceType":"module"}