{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { abi as IUniswapV2PairABI } from \"@uniswap/v2-core/build/IUniswapV2Pair.json\";\nimport { Interface } from \"@ethersproject/abi\";\n// import { wrappedCurrency } from '../utils/wrappedCurrency'\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\nexport let PairState;\n\n(function (PairState) {\n  PairState[PairState[\"LOADING\"] = 0] = \"LOADING\";\n  PairState[PairState[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PairState[PairState[\"EXISTS\"] = 2] = \"EXISTS\";\n  PairState[PairState[\"INVALID\"] = 3] = \"INVALID\";\n})(PairState || (PairState = {}));\n\nexport function usePairs(currencies) {\n  // const { chainId } = useActiveWeb3React()\n  return null; // const tokens = useMemo(\n  //   () =>\n  //     currencies.map(([currencyA, currencyB]) => [\n  //       wrappedCurrency(currencyA, chainId),\n  //       wrappedCurrency(currencyB, chainId)\n  //     ]),\n  //   [chainId, currencies]\n  // )\n  // const pairAddresses = useMemo(\n  //   () =>\n  //     tokens.map(([tokenA, tokenB]) => {\n  //       return tokenA && tokenB && !tokenA.equals(tokenB) ? Pair.getAddress(tokenA, tokenB) : undefined\n  //     }),\n  //   [tokens]\n  // )\n  // const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves')\n  // return useMemo(() => {\n  //   return results.map((result, i) => {\n  //     const { result: reserves, loading } = result\n  //     const tokenA = tokens[i][0]\n  //     const tokenB = tokens[i][1]\n  //     if (loading) return [PairState.LOADING, null]\n  //     if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null]\n  //     if (!reserves) return [PairState.NOT_EXISTS, null]\n  //     const { reserve0, reserve1 } = reserves\n  //     const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n  //     return [\n  //       PairState.EXISTS,\n  //       new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()))\n  //     ]\n  //   })\n  // }, [results, tokens])\n}\nexport function usePair(tokenA, tokenB) {\n  _s();\n\n  return usePairs([[tokenA, tokenB]])[0];\n}\n\n_s(usePair, \"AJtW1Ot38FORoSrNpUliDLrh4e4=\", false, function () {\n  return [usePairs];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/data/Reserves.ts"],"names":["abi","IUniswapV2PairABI","Interface","PAIR_INTERFACE","PairState","usePairs","currencies","usePair","tokenA","tokenB"],"mappings":";;AAEA,SAASA,GAAG,IAAIC,iBAAhB,QAAyC,4CAAzC;AACA,SAASC,SAAT,QAA0B,oBAA1B;AAIA;AAEA,MAAMC,cAAc,GAAG,IAAID,SAAJ,CAAcD,iBAAd,CAAvB;AAEA,WAAYG,SAAZ;;WAAYA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;GAAAA,S,KAAAA,S;;AAOZ,OAAO,SAASC,QAAT,CACLC,UADK,EAEC;AACN;AAEA,SAAO,IAAP,CAHM,CAIN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;AAED,OAAO,SAASC,OAAT,CACLC,MADK,EAELC,MAFK,EAGqB;AAAA;;AAC1B,SAAOJ,QAAQ,CAAC,CAAC,CAACG,MAAD,EAASC,MAAT,CAAD,CAAD,CAAR,CAA6B,CAA7B,CAAP;AACD;;GALeF,O;UAIPF,Q","sourcesContent":["import { TokenAmount, Pair, Currency } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { abi as IUniswapV2PairABI } from \"@uniswap/v2-core/build/IUniswapV2Pair.json\";\nimport { Interface } from \"@ethersproject/abi\";\nimport { useActiveWeb3React } from \"../hooks\";\n\nimport { useMultipleContractSingleData } from \"../state/multicall/hooks\";\n// import { wrappedCurrency } from '../utils/wrappedCurrency'\n\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\n\nexport enum PairState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function usePairs(\n  currencies: [Currency | undefined, Currency | undefined][]\n): null {\n  // const { chainId } = useActiveWeb3React()\n\n  return null;\n  // const tokens = useMemo(\n  //   () =>\n  //     currencies.map(([currencyA, currencyB]) => [\n  //       wrappedCurrency(currencyA, chainId),\n  //       wrappedCurrency(currencyB, chainId)\n  //     ]),\n  //   [chainId, currencies]\n  // )\n\n  // const pairAddresses = useMemo(\n  //   () =>\n  //     tokens.map(([tokenA, tokenB]) => {\n  //       return tokenA && tokenB && !tokenA.equals(tokenB) ? Pair.getAddress(tokenA, tokenB) : undefined\n  //     }),\n  //   [tokens]\n  // )\n\n  // const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves')\n\n  // return useMemo(() => {\n  //   return results.map((result, i) => {\n  //     const { result: reserves, loading } = result\n  //     const tokenA = tokens[i][0]\n  //     const tokenB = tokens[i][1]\n\n  //     if (loading) return [PairState.LOADING, null]\n  //     if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null]\n  //     if (!reserves) return [PairState.NOT_EXISTS, null]\n  //     const { reserve0, reserve1 } = reserves\n  //     const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n  //     return [\n  //       PairState.EXISTS,\n  //       new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()))\n  //     ]\n  //   })\n  // }, [results, tokens])\n}\n\nexport function usePair(\n  tokenA?: Currency,\n  tokenB?: Currency\n): [PairState, Pair | null] {\n  return usePairs([[tokenA, tokenB]])[0];\n}\n"]},"metadata":{},"sourceType":"module"}