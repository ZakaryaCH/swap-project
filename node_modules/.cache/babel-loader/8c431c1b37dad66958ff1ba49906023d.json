{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { ETHER, Pair, Route, Token, TokenAmount, Trade, TradeType, WETH } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { useAllTokens } from \"../hooks/Tokens\";\nimport { useV1FactoryContract } from \"../hooks/useContract\";\nimport { Version } from \"../hooks/useToggledVersion\";\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from \"../state/multicall/hooks\";\nimport { useETHBalances, useTokenBalance } from \"../state/wallet/hooks\";\nexport function useV1ExchangeAddress(tokenAddress) {\n  _s();\n\n  var _useSingleCallResult, _useSingleCallResult$;\n\n  const contract = useV1FactoryContract();\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return (_useSingleCallResult = useSingleCallResult(contract, \"getExchange\", inputs)) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n}\n\n_s(useV1ExchangeAddress, \"diwIceYheILuw1PL3XW/X7/DaqM=\", false, function () {\n  return [useV1FactoryContract, useSingleCallResult];\n});\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount, tokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount));\n  }\n\n}\n\nfunction useMockV1Pair(inputCurrency) {\n  _s2();\n\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token === null || token === void 0 ? void 0 : token.address);\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress !== null && v1PairAddress !== void 0 ? v1PairAddress : \"\"];\n  return useMemo(() => token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined, [ETHBalance, inputCurrency, token, tokenBalance]);\n} // returns all v1 exchange addresses in the user's token list\n\n\n_s2(useMockV1Pair, \"UjsURM5xPXHcWilodqQuAyveaww=\", false, function () {\n  return [useV1ExchangeAddress, useTokenBalance, useETHBalances];\n});\n\nexport function useAllTokenV1Exchanges() {\n  _s3();\n\n  const allTokens = useAllTokens();\n  const factory = useV1FactoryContract();\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens]);\n  const data = useSingleContractMultipleData(factory, \"getExchange\", args, NEVER_RELOAD);\n  return useMemo(() => {\n    var _data$reduce;\n\n    return (_data$reduce = data === null || data === void 0 ? void 0 : data.reduce((memo, {\n      result\n    }, ix) => {\n      if ((result === null || result === void 0 ? void 0 : result[0]) && result[0] !== AddressZero) {\n        memo[result[0]] = allTokens[args[ix][0]];\n      }\n\n      return memo;\n    }, {})) !== null && _data$reduce !== void 0 ? _data$reduce : {};\n  }, [allTokens, args, data]);\n} // returns whether any of the tokens in the user's token list have liquidity on v1\n// export function useUserHasLiquidityInAllTokens(): boolean | undefined {\n//   const { account, chainId } = useActiveWeb3React()\n//   const exchanges = useAllTokenV1Exchanges()\n//   const v1ExchangeLiquidityTokens = useMemo(\n//     () =>\n//       chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n//     [chainId, exchanges]\n//   )\n//   const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n//   return useMemo(\n//     () =>\n//       Object.keys(balances).some(tokenAddress => {\n//         const b = balances[tokenAddress]?.raw\n//         return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n//       }),\n//     [balances]\n//   )\n// }\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\n\n_s3(useAllTokenV1Exchanges, \"EEpN4IBLeFPxNqdwdHjZDwBloSA=\", false, function () {\n  return [useAllTokens, useV1FactoryContract, useSingleContractMultipleData];\n});\n\nexport function useV1Trade(isExactIn, inputCurrency, outputCurrency, exactAmount) {\n  _s4();\n\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER; // construct a direct or through ETH v1 route\n\n  let pairs = [];\n\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  } // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n      pairs = [inputPair, outputPair];\n    }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade;\n\n  try {\n    v1Trade = route && exactAmount ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT) : undefined;\n  } catch (error) {\n    console.debug(\"Failed to create V1 trade\", error);\n  }\n\n  return v1Trade;\n}\n\n_s4(useV1Trade, \"0vh+JJLbgPh9RAcnEjiYjwnunbk=\", false, function () {\n  return [useMockV1Pair, useMockV1Pair];\n});\n\nexport function getTradeVersion(trade) {\n  var _trade$route, _trade$route$pairs;\n\n  const isV1 = trade === null || trade === void 0 ? void 0 : (_trade$route = trade.route) === null || _trade$route === void 0 ? void 0 : (_trade$route$pairs = _trade$route.pairs) === null || _trade$route$pairs === void 0 ? void 0 : _trade$route$pairs.some(pair => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n} // returns the v1 exchange against which a trade should be executed\n\nexport function useV1TradeExchangeAddress(trade) {\n  _s5();\n\n  const tokenAddress = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount ? trade.inputAmount.token.address : trade.outputAmount instanceof TokenAmount ? trade.outputAmount.token.address : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}\n\n_s5(useV1TradeExchangeAddress, \"dGMSMt3qM8GyaWcSoa4bZcqoiKw=\", false, function () {\n  return [useV1ExchangeAddress];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/data/V1.ts"],"names":["AddressZero","ETHER","Pair","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useAllTokens","useV1FactoryContract","Version","NEVER_RELOAD","useSingleCallResult","useSingleContractMultipleData","useETHBalances","useTokenBalance","useV1ExchangeAddress","tokenAddress","contract","inputs","result","MockV1Pair","constructor","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","allTokens","factory","args","Object","keys","map","data","reduce","memo","ix","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","isV1","some","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount"],"mappings":"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","sourcesContent":["import { AddressZero } from \"@ethersproject/constants\";\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Pair,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH,\n} from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { useActiveWeb3React } from \"../hooks\";\nimport { useAllTokens } from \"../hooks/Tokens\";\nimport { useV1FactoryContract } from \"../hooks/useContract\";\nimport { Version } from \"../hooks/useToggledVersion\";\nimport {\n  NEVER_RELOAD,\n  useSingleCallResult,\n  useSingleContractMultipleData,\n} from \"../state/multicall/hooks\";\nimport {\n  useETHBalances,\n  useTokenBalance,\n  useTokenBalances,\n} from \"../state/wallet/hooks\";\n\nexport function useV1ExchangeAddress(\n  tokenAddress?: string\n): string | undefined {\n  const contract = useV1FactoryContract();\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return useSingleCallResult(contract, \"getExchange\", inputs)?.result?.[0];\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(\n      tokenAmount,\n      new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount)\n    );\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(\n    isWETH ? undefined : token?.address\n  );\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? \"\"];\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency\n        ? new MockV1Pair(ETHBalance.raw, tokenBalance)\n        : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  );\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  const allTokens = useAllTokens();\n  const factory = useV1FactoryContract();\n  const args = useMemo(\n    () => Object.keys(allTokens).map((tokenAddress) => [tokenAddress]),\n    [allTokens]\n  );\n\n  const data = useSingleContractMultipleData(\n    factory,\n    \"getExchange\",\n    args,\n    NEVER_RELOAD\n  );\n\n  return useMemo(\n    () =>\n      data?.reduce<{ [exchangeAddress: string]: Token }>(\n        (memo, { result }, ix) => {\n          if (result?.[0] && result[0] !== AddressZero) {\n            memo[result[0]] = allTokens[args[ix][0]];\n          }\n          return memo;\n        },\n        {}\n      ) ?? {},\n    [allTokens, args, data]\n  );\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\n// export function useUserHasLiquidityInAllTokens(): boolean | undefined {\n//   const { account, chainId } = useActiveWeb3React()\n\n//   const exchanges = useAllTokenV1Exchanges()\n\n//   const v1ExchangeLiquidityTokens = useMemo(\n//     () =>\n//       chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n//     [chainId, exchanges]\n//   )\n\n//   const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n//   return useMemo(\n//     () =>\n//       Object.keys(balances).some(tokenAddress => {\n//         const b = balances[tokenAddress]?.raw\n//         return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n//       }),\n//     [balances]\n//   )\n// }\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER;\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = [];\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair];\n  }\n\n  const route =\n    inputCurrency &&\n    pairs &&\n    pairs.length > 0 &&\n    new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade: Trade | undefined;\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(\n            route,\n            exactAmount,\n            isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT\n          )\n        : undefined;\n  } catch (error) {\n    console.debug(\"Failed to create V1 trade\", error);\n  }\n  return v1Trade;\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some((pair) => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(\n  trade: Trade | undefined\n): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}\n"]},"metadata":{},"sourceType":"module"}