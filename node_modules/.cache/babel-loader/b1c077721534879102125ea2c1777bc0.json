{"ast":null,"code":"import { ETHER, Token, TokenAmount } from \"@uniswap/sdk\";\nimport { BNB } from \"../types\";\nexport function wrappedCurrency(currency, chainId) {\n  return chainId && currency === ETHER ? BNB[chainId] : currency instanceof Token ? currency : undefined;\n}\nexport function wrappedCurrencyAmount(currencyAmount, chainId) {\n  const token = currencyAmount && chainId ? wrappedCurrency(currencyAmount.currency, chainId) : undefined;\n  return token && currencyAmount ? new TokenAmount(token, currencyAmount.raw) : undefined;\n}\nexport function unwrappedToken(token) {\n  if (token.equals(BNB[token.chainId])) return ETHER;\n  return token;\n}","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/utils/wrappedCurrency.ts"],"names":["ETHER","Token","TokenAmount","BNB","wrappedCurrency","currency","chainId","undefined","wrappedCurrencyAmount","currencyAmount","token","raw","unwrappedToken","equals"],"mappings":"AAAA,SAGEA,KAHF,EAIEC,KAJF,EAKEC,WALF,QAMO,cANP;AAOA,SAAkBC,GAAlB,QAA6B,UAA7B;AACA,OAAO,SAASC,eAAT,CACLC,QADK,EAELC,OAFK,EAGc;AACnB,SAAOA,OAAO,IAAID,QAAQ,KAAKL,KAAxB,GACHG,GAAG,CAACG,OAAD,CADA,GAEHD,QAAQ,YAAYJ,KAApB,GACAI,QADA,GAEAE,SAJJ;AAKD;AAED,OAAO,SAASC,qBAAT,CACLC,cADK,EAELH,OAFK,EAGoB;AACzB,QAAMI,KAAK,GACTD,cAAc,IAAIH,OAAlB,GACIF,eAAe,CAACK,cAAc,CAACJ,QAAhB,EAA0BC,OAA1B,CADnB,GAEIC,SAHN;AAIA,SAAOG,KAAK,IAAID,cAAT,GACH,IAAIP,WAAJ,CAAgBQ,KAAhB,EAAuBD,cAAc,CAACE,GAAtC,CADG,GAEHJ,SAFJ;AAGD;AAED,OAAO,SAASK,cAAT,CAAwBF,KAAxB,EAAgD;AACrD,MAAIA,KAAK,CAACG,MAAN,CAAaV,GAAG,CAACO,KAAK,CAACJ,OAAP,CAAhB,CAAJ,EAAsC,OAAON,KAAP;AACtC,SAAOU,KAAP;AACD","sourcesContent":["import {\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  Token,\n  TokenAmount,\n} from \"@uniswap/sdk\";\nimport { ChainId, BNB } from \"../types\";\nexport function wrappedCurrency(\n  currency: Currency | undefined,\n  chainId: ChainId | undefined\n): Token | undefined {\n  return chainId && currency === ETHER\n    ? BNB[chainId]\n    : currency instanceof Token\n    ? currency\n    : undefined;\n}\n\nexport function wrappedCurrencyAmount(\n  currencyAmount: CurrencyAmount | undefined,\n  chainId: ChainId | undefined\n): TokenAmount | undefined {\n  const token =\n    currencyAmount && chainId\n      ? wrappedCurrency(currencyAmount.currency, chainId)\n      : undefined;\n  return token && currencyAmount\n    ? new TokenAmount(token, currencyAmount.raw)\n    : undefined;\n}\n\nexport function unwrappedToken(token: Token): Currency {\n  if (token.equals(BNB[token.chainId])) return ETHER;\n  return token;\n}\n"]},"metadata":{},"sourceType":"module"}