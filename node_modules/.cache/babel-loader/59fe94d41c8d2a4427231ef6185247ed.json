{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useAllLists } from \"state/lists/hooks\";\nimport { getVersionUpgrade, minVersionBump, VersionUpgrade } from \"@uniswap/token-lists\";\nimport { useCallback, useEffect } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useFetchListCallback } from \"../../hooks/useFetchListCallback\";\nimport useInterval from \"../../hooks/useInterval\";\nimport useIsWindowVisible from \"../../hooks/useIsWindowVisible\";\nimport { acceptListUpdate } from \"./actions\";\nimport { useActiveListUrls } from \"./hooks\";\nimport { useAllInactiveTokens } from \"hooks/Tokens\";\nexport default function Updater() {\n  _s();\n\n  const {\n    library\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  const isWindowVisible = useIsWindowVisible(); // get all loaded lists, and the active urls\n\n  const lists = useAllLists();\n  const activeListUrls = useActiveListUrls(); // initiate loading\n\n  useAllInactiveTokens();\n  const fetchList = useFetchListCallback();\n  const fetchAllListsCallback = useCallback(() => {\n    if (!isWindowVisible) return;\n    Object.keys(lists).forEach(url => fetchList().catch(error => console.debug(\"interval list fetching error\", error)));\n  }, [fetchList, isWindowVisible, lists]); // fetch all lists every 10 minutes, but only after we initialize library\n\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null); // whenever a list is not loaded and not loading, try again to load it\n\n  useEffect(() => {\n    Object.keys(lists).forEach(listUrl => {\n      const list = lists[listUrl];\n\n      if (!list.current && !list.loadingRequestId && !list.error) {\n        fetchList().catch(error => console.debug(\"list added fetching error\", error));\n      }\n    });\n  }, [dispatch, fetchList, library, lists]); // automatically update lists if versions are minor/patch\n\n  useEffect(() => {\n    Object.keys(lists).forEach(listUrl => {\n      const list = lists[listUrl];\n\n      if (list.current && list.pendingUpdate) {\n        const bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version);\n\n        switch (bump) {\n          case VersionUpgrade.NONE:\n            throw new Error(\"unexpected no version bump\");\n\n          case VersionUpgrade.PATCH:\n          case VersionUpgrade.MINOR:\n            const min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens); // automatically update minor/patch as long as bump matches the min update\n\n            if (bump >= min) {\n              dispatch(acceptListUpdate(listUrl));\n            } else {\n              console.error(`List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`);\n            }\n\n            break;\n          // update any active or inactive lists\n\n          case VersionUpgrade.MAJOR:\n            dispatch(acceptListUpdate(listUrl));\n        }\n      }\n    });\n  }, [dispatch, lists, activeListUrls]);\n  return null;\n}\n\n_s(Updater, \"gazarun/2iqQmX2+jZsKWn4gVbM=\", false, function () {\n  return [useActiveWeb3React, useDispatch, useIsWindowVisible, useAllLists, useActiveListUrls, useAllInactiveTokens, useFetchListCallback, useInterval];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/state/lists/updater.ts"],"names":["useAllLists","getVersionUpgrade","minVersionBump","VersionUpgrade","useCallback","useEffect","useDispatch","useActiveWeb3React","useFetchListCallback","useInterval","useIsWindowVisible","acceptListUpdate","useActiveListUrls","useAllInactiveTokens","Updater","library","dispatch","isWindowVisible","lists","activeListUrls","fetchList","fetchAllListsCallback","Object","keys","forEach","url","catch","error","console","debug","listUrl","list","current","loadingRequestId","pendingUpdate","bump","version","NONE","Error","PATCH","MINOR","min","tokens","MAJOR"],"mappings":"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","sourcesContent":["import { useAllLists } from \"state/lists/hooks\";\nimport {\n  getVersionUpgrade,\n  minVersionBump,\n  VersionUpgrade,\n} from \"@uniswap/token-lists\";\nimport { useCallback, useEffect } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useFetchListCallback } from \"../../hooks/useFetchListCallback\";\nimport useInterval from \"../../hooks/useInterval\";\nimport useIsWindowVisible from \"../../hooks/useIsWindowVisible\";\nimport { AppDispatch } from \"../index\";\nimport { acceptListUpdate } from \"./actions\";\nimport { useActiveListUrls } from \"./hooks\";\nimport { useAllInactiveTokens } from \"hooks/Tokens\";\n\nexport default function Updater(): null {\n  const { library } = useActiveWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n  const isWindowVisible = useIsWindowVisible();\n\n  // get all loaded lists, and the active urls\n  const lists = useAllLists();\n  const activeListUrls = useActiveListUrls();\n\n  // initiate loading\n  useAllInactiveTokens();\n\n  const fetchList = useFetchListCallback();\n  const fetchAllListsCallback = useCallback(() => {\n    if (!isWindowVisible) return;\n    Object.keys(lists).forEach((url) =>\n      fetchList().catch((error) =>\n        console.debug(\"interval list fetching error\", error)\n      )\n    );\n  }, [fetchList, isWindowVisible, lists]);\n\n  // fetch all lists every 10 minutes, but only after we initialize library\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);\n\n  // whenever a list is not loaded and not loading, try again to load it\n  useEffect(() => {\n    Object.keys(lists).forEach((listUrl) => {\n      const list = lists[listUrl];\n      if (!list.current && !list.loadingRequestId && !list.error) {\n        fetchList().catch((error) =>\n          console.debug(\"list added fetching error\", error)\n        );\n      }\n    });\n  }, [dispatch, fetchList, library, lists]);\n\n  // automatically update lists if versions are minor/patch\n  useEffect(() => {\n    Object.keys(lists).forEach((listUrl) => {\n      const list = lists[listUrl];\n      if (list.current && list.pendingUpdate) {\n        const bump = getVersionUpgrade(\n          list.current.version,\n          list.pendingUpdate.version\n        );\n        switch (bump) {\n          case VersionUpgrade.NONE:\n            throw new Error(\"unexpected no version bump\");\n          case VersionUpgrade.PATCH:\n          case VersionUpgrade.MINOR:\n            const min = minVersionBump(\n              list.current.tokens,\n              list.pendingUpdate.tokens\n            );\n            // automatically update minor/patch as long as bump matches the min update\n            if (bump >= min) {\n              dispatch(acceptListUpdate(listUrl));\n            } else {\n              console.error(\n                `List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`\n              );\n            }\n            break;\n\n          // update any active or inactive lists\n          case VersionUpgrade.MAJOR:\n            dispatch(acceptListUpdate(listUrl));\n        }\n      }\n    });\n  }, [dispatch, lists, activeListUrls]);\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}