{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$();\n\nimport { CurrencyAmount, ETHER, JSBI, Token, TokenAmount } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport ERC20_INTERFACE from \"../../constants/abis/erc20\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useMulticallContract } from \"../../hooks/useContract\";\nimport { isAddress } from \"../../utils\";\nimport { useSingleContractMultipleData, useMultipleContractSingleData } from \"../multicall/hooks\";\nimport { useUserUnclaimedAmount } from \"../claim/hooks\";\nimport { useTotalUniEarned } from \"../stake/hooks\";\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\n\nexport function useETHBalances(uncheckedAddresses) {\n  _s();\n\n  const multicallContract = useMulticallContract();\n  const addresses = useMemo(() => uncheckedAddresses ? uncheckedAddresses.map(isAddress).filter(a => a !== false).sort() : [], [uncheckedAddresses]);\n  const results = useSingleContractMultipleData(multicallContract, \"getEthBalance\", addresses.map(address => [address]));\n  return useMemo(() => addresses.reduce((memo, address, i) => {\n    var _results$i, _results$i$result;\n\n    const value = results === null || results === void 0 ? void 0 : (_results$i = results[i]) === null || _results$i === void 0 ? void 0 : (_results$i$result = _results$i.result) === null || _results$i$result === void 0 ? void 0 : _results$i$result[0];\n    if (value) memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()));\n    return memo;\n  }, {}), [addresses, results]);\n}\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\n\n_s(useETHBalances, \"o7Qz5DDFtdCrnN3OVML6d6f0xis=\", false, function () {\n  return [useMulticallContract, useSingleContractMultipleData];\n});\n\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  _s2();\n\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, \"balanceOf\", [address]);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return [useMemo(() => address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n\n    if (amount) {\n      memo[token.address] = new TokenAmount(token, amount);\n    }\n\n    return memo;\n  }, {}) : {}, [address, validatedTokens, balances]), anyLoading];\n}\n\n_s2(useTokenBalancesWithLoadingIndicator, \"SCK9OM08RM+gVw11exo8N+EChV4=\", false, function () {\n  return [useMultipleContractSingleData];\n});\n\nexport function useTokenBalances(address, tokens) {\n  _s3();\n\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n} // get the balance for a single token/account combo\n\n_s3(useTokenBalances, \"mWHFhmTyaoodDeiE1Op0b2ODA8c=\", false, function () {\n  return [useTokenBalancesWithLoadingIndicator];\n});\n\nexport function useTokenBalance(account, token) {\n  _s4();\n\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\n\n_s4(useTokenBalance, \"Bs7OvuixKI6epyl0XTe28FcYl68=\", false, function () {\n  return [useTokenBalances];\n});\n\nexport function useCurrencyBalances(account, currencies) {\n  _s5();\n\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => currency instanceof Token)) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH = useMemo(() => {\n    var _currencies$some;\n\n    return (_currencies$some = currencies === null || currencies === void 0 ? void 0 : currencies.some(currency => currency === ETHER)) !== null && _currencies$some !== void 0 ? _currencies$some : false;\n  }, [currencies]);\n  const ethBalance = useETHBalances(containsETH ? [account] : []);\n  return useMemo(() => {\n    var _currencies$map;\n\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return undefined;\n      if (currency instanceof Token) return tokenBalances[currency.address];\n      if (currency === ETHER) return ethBalance[account];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, ethBalance, tokenBalances]);\n}\n\n_s5(useCurrencyBalances, \"HabFpTOEEpdczAwAh/KWdJQ9Ts0=\", false, function () {\n  return [useTokenBalances, useETHBalances];\n});\n\nexport function useCurrencyBalance(account, currency) {\n  _s6();\n\n  return useCurrencyBalances(account, [currency])[0];\n} // mimics useAllBalances\n\n_s6(useCurrencyBalance, \"ujXQyrriKnCrImnzvRCr5xp5xyc=\", false, function () {\n  return [useCurrencyBalances];\n});\n\nexport function useAllTokenBalances() {\n  _s7();\n\n  const {\n    account\n  } = useActiveWeb3React(); // const allTokens = useAllTokens();\n\n  const allTokensArray = useMemo(() => {\n    var _allTokens;\n\n    return Object.values((_allTokens = allTokens) !== null && _allTokens !== void 0 ? _allTokens : {});\n  }, [allTokens]); // const balances = useTokenBalances(account ?? undefined, allTokensArray);\n  // return balances ?? {};\n\n  return null;\n} // get the total owned, unclaimed, and unharvested UNI for account\n\n_s7(useAllTokenBalances, \"EVD9JxfFV03eO3aBMFayjZzqrbs=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useAggregateUniBalance() {\n  _s8();\n\n  var _uniBalance$raw, _uniUnclaimed$raw, _uniUnHarvested$raw;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React(); // const uni = chainId ? UNI[chainId] : undefined;\n\n  const uniBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, uni);\n  const uniUnclaimed = useUserUnclaimedAmount(account);\n  const uniUnHarvested = useTotalUniEarned();\n  if (!uni) return undefined;\n  return new TokenAmount(uni, JSBI.add(JSBI.add((_uniBalance$raw = uniBalance === null || uniBalance === void 0 ? void 0 : uniBalance.raw) !== null && _uniBalance$raw !== void 0 ? _uniBalance$raw : JSBI.BigInt(0), (_uniUnclaimed$raw = uniUnclaimed === null || uniUnclaimed === void 0 ? void 0 : uniUnclaimed.raw) !== null && _uniUnclaimed$raw !== void 0 ? _uniUnclaimed$raw : JSBI.BigInt(0)), (_uniUnHarvested$raw = uniUnHarvested === null || uniUnHarvested === void 0 ? void 0 : uniUnHarvested.raw) !== null && _uniUnHarvested$raw !== void 0 ? _uniUnHarvested$raw : JSBI.BigInt(0)));\n}\n\n_s8(useAggregateUniBalance, \"pSszkizWFJx+MumvbCB8eMN9Hv0=\", false, function () {\n  return [useActiveWeb3React, useTokenBalance, useUserUnclaimedAmount, useTotalUniEarned];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/state/wallet/hooks.ts"],"names":["CurrencyAmount","ETHER","JSBI","Token","TokenAmount","useMemo","ERC20_INTERFACE","useActiveWeb3React","useMulticallContract","isAddress","useSingleContractMultipleData","useMultipleContractSingleData","useUserUnclaimedAmount","useTotalUniEarned","useETHBalances","uncheckedAddresses","multicallContract","addresses","map","filter","a","sort","results","address","reduce","memo","i","value","result","ether","BigInt","toString","useTokenBalancesWithLoadingIndicator","tokens","validatedTokens","t","validatedTokenAddresses","vt","balances","anyLoading","some","callState","loading","length","token","amount","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","currency","containsETH","ethBalance","useCurrencyBalance","useAllTokenBalances","allTokensArray","Object","values","allTokens","useAggregateUniBalance","chainId","uniBalance","uni","uniUnclaimed","uniUnHarvested","add","raw"],"mappings":"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","sourcesContent":["import {\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Token,\n  TokenAmount,\n} from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport ERC20_INTERFACE from \"../../constants/abis/erc20\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useMulticallContract } from \"../../hooks/useContract\";\nimport { isAddress } from \"../../utils\";\nimport {\n  useSingleContractMultipleData,\n  useMultipleContractSingleData,\n} from \"../multicall/hooks\";\nimport { useUserUnclaimedAmount } from \"../claim/hooks\";\nimport { useTotalUniEarned } from \"../stake/hooks\";\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useETHBalances(uncheckedAddresses?: (string | undefined)[]): {\n  [address: string]: CurrencyAmount | undefined;\n} {\n  const multicallContract = useMulticallContract();\n\n  const addresses: string[] = useMemo(\n    () =>\n      uncheckedAddresses\n        ? uncheckedAddresses\n            .map(isAddress)\n            .filter((a): a is string => a !== false)\n            .sort()\n        : [],\n    [uncheckedAddresses]\n  );\n\n  const results = useSingleContractMultipleData(\n    multicallContract,\n    \"getEthBalance\",\n    addresses.map((address) => [address])\n  );\n\n  return useMemo(\n    () =>\n      addresses.reduce<{ [address: string]: CurrencyAmount }>(\n        (memo, address, i) => {\n          const value = results?.[i]?.result?.[0];\n          if (value)\n            memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()));\n          return memo;\n        },\n        {}\n      ),\n    [addresses, results]\n  );\n}\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () =>\n      tokens?.filter(\n        (t?: Token): t is Token => isAddress(t?.address) !== false\n      ) ?? [],\n    [tokens]\n  );\n\n  const validatedTokenAddresses = useMemo(\n    () => validatedTokens.map((vt) => vt.address),\n    [validatedTokens]\n  );\n\n  const balances = useMultipleContractSingleData(\n    validatedTokenAddresses,\n    ERC20_INTERFACE,\n    \"balanceOf\",\n    [address]\n  );\n\n  const anyLoading: boolean = useMemo(\n    () => balances.some((callState) => callState.loading),\n    [balances]\n  );\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{\n              [tokenAddress: string]: TokenAmount | undefined;\n            }>((memo, token, i) => {\n              const value = balances?.[i]?.result?.[0];\n              const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n              if (amount) {\n                memo[token.address] = new TokenAmount(token, amount);\n              }\n              return memo;\n            }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading,\n  ];\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(\n  account?: string,\n  token?: Token\n): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\n\nexport function useCurrencyBalances(\n  account?: string,\n  currencies?: (Currency | undefined)[]\n): (CurrencyAmount | undefined)[] {\n  const tokens = useMemo(\n    () =>\n      currencies?.filter(\n        (currency): currency is Token => currency instanceof Token\n      ) ?? [],\n    [currencies]\n  );\n\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH: boolean = useMemo(\n    () => currencies?.some((currency) => currency === ETHER) ?? false,\n    [currencies]\n  );\n  const ethBalance = useETHBalances(containsETH ? [account] : []);\n\n  return useMemo(\n    () =>\n      currencies?.map((currency) => {\n        if (!account || !currency) return undefined;\n        if (currency instanceof Token) return tokenBalances[currency.address];\n        if (currency === ETHER) return ethBalance[account];\n        return undefined;\n      }) ?? [],\n    [account, currencies, ethBalance, tokenBalances]\n  );\n}\n\nexport function useCurrencyBalance(\n  account?: string,\n  currency?: Currency\n): CurrencyAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0];\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): {\n  [tokenAddress: string]: TokenAmount | undefined;\n} {\n  const { account } = useActiveWeb3React();\n  // const allTokens = useAllTokens();\n  const allTokensArray = useMemo(\n    () => Object.values(allTokens ?? {}),\n    [allTokens]\n  );\n  // const balances = useTokenBalances(account ?? undefined, allTokensArray);\n  // return balances ?? {};\n  return null;\n}\n\n// get the total owned, unclaimed, and unharvested UNI for account\nexport function useAggregateUniBalance(): TokenAmount | undefined {\n  const { account, chainId } = useActiveWeb3React();\n\n  // const uni = chainId ? UNI[chainId] : undefined;\n\n  const uniBalance: TokenAmount | undefined = useTokenBalance(\n    account ?? undefined,\n    uni\n  );\n  const uniUnclaimed: TokenAmount | undefined = useUserUnclaimedAmount(account);\n  const uniUnHarvested: TokenAmount | undefined = useTotalUniEarned();\n\n  if (!uni) return undefined;\n\n  return new TokenAmount(\n    uni,\n    JSBI.add(\n      JSBI.add(\n        uniBalance?.raw ?? JSBI.BigInt(0),\n        uniUnclaimed?.raw ?? JSBI.BigInt(0)\n      ),\n      uniUnHarvested?.raw ?? JSBI.BigInt(0)\n    )\n  );\n}\n"]},"metadata":{},"sourceType":"module"}