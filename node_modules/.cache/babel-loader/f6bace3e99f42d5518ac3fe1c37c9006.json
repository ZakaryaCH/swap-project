{"ast":null,"code":"export let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  // {\n  //   wrapType: WrapType;\n  //   execute?: undefined | (() => Promise<void>);\n  //   inputError?: string;\n  // }\n  // const { chainId, account } = useActiveWeb3React();\n  // // const wethContract = useWETHContract()\n  // const balance = useCurrencyBalance(account ?? undefined, inputCurrency);\n  // // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  // const inputAmount = useMemo(\n  //   () => tryParseAmount(typedValue, inputCurrency),\n  //   [inputCurrency, typedValue]\n  // );\n  // const addTransaction = useTransactionAdder();\n  // return useMemo(() => {\n  //   if (!wethContract || !chainId || !inputCurrency || !outputCurrency)\n  //     return NOT_APPLICABLE;\n  //   const sufficientBalance =\n  //     inputAmount && balance && !balance.lessThan(inputAmount);\n  //   if (\n  //     inputCurrency === ETHER &&\n  //     currencyEquals(WETH[chainId], outputCurrency)\n  //   ) {\n  //     return {\n  //       wrapType: WrapType.WRAP,\n  //       execute:\n  //         sufficientBalance && inputAmount\n  //           ? async () => {\n  //               try {\n  //                 const txReceipt = await wethContract.deposit({\n  //                   value: `0x${inputAmount.raw.toString(16)}`,\n  //                 });\n  //                 addTransaction(txReceipt, {\n  //                   summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH`,\n  //                 });\n  //               } catch (error) {\n  //                 console.error(\"Could not deposit\", error);\n  //               }\n  //             }\n  //           : undefined,\n  //       inputError: sufficientBalance ? undefined : \"Insufficient ETH balance\",\n  //     };\n  //   } else if (\n  //     currencyEquals(WETH[chainId], inputCurrency) &&\n  //     outputCurrency === ETHER\n  //   ) {\n  //     return {\n  //       wrapType: WrapType.UNWRAP,\n  //       execute:\n  //         sufficientBalance && inputAmount\n  //           ? async () => {\n  //               try {\n  //                 const txReceipt = await wethContract.withdraw(\n  //                   `0x${inputAmount.raw.toString(16)}`\n  //                 );\n  //                 addTransaction(txReceipt, {\n  //                   summary: `Unwrap ${inputAmount.toSignificant(\n  //                     6\n  //                   )} WETH to ETH`,\n  //                 });\n  //               } catch (error) {\n  //                 console.error(\"Could not withdraw\", error);\n  //               }\n  //             }\n  //           : undefined,\n  //       inputError: sufficientBalance ? undefined : \"Insufficient WETH balance\",\n  //     };\n  //   } else {\n  //     return NOT_APPLICABLE;\n  //   }\n  return null; //   }, [\n  //     // wethContract,\n  //     // chainId,\n  //     // inputCurrency,\n  //     // outputCurrency,\n  //     // inputAmount,\n  //     // balance,\n  //     // addTransaction,\n  //   ]);\n}","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/hooks/useWrapCallback.ts"],"names":["WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue"],"mappings":"AAOA,WAAYA,QAAZ;;WAAYA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;GAAAA,Q,KAAAA,Q;;AAMZ,MAAMC,cAAc,GAAG;AAAEC,EAAAA,QAAQ,EAAEF,QAAQ,CAACC;AAArB,CAAvB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASE,eAAT,CACbC,aADa,EAEbC,cAFa,EAGbC,UAHa,EAIP;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAO,IAAP,CA1EM,CA2EN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD","sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from \"@uniswap/sdk\";\nimport { useMemo } from \"react\";\nimport { tryParseAmount } from \"../state/swap/hooks\";\nimport { useTransactionAdder } from \"../state/transactions/hooks\";\nimport { useCurrencyBalance } from \"../state/wallet/hooks\";\nimport { useActiveWeb3React } from \"./index\";\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  typedValue: string | undefined\n): null {\n  // {\n  //   wrapType: WrapType;\n  //   execute?: undefined | (() => Promise<void>);\n  //   inputError?: string;\n  // }\n  // const { chainId, account } = useActiveWeb3React();\n  // // const wethContract = useWETHContract()\n  // const balance = useCurrencyBalance(account ?? undefined, inputCurrency);\n  // // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  // const inputAmount = useMemo(\n  //   () => tryParseAmount(typedValue, inputCurrency),\n  //   [inputCurrency, typedValue]\n  // );\n  // const addTransaction = useTransactionAdder();\n\n  // return useMemo(() => {\n  //   if (!wethContract || !chainId || !inputCurrency || !outputCurrency)\n  //     return NOT_APPLICABLE;\n\n  //   const sufficientBalance =\n  //     inputAmount && balance && !balance.lessThan(inputAmount);\n\n  //   if (\n  //     inputCurrency === ETHER &&\n  //     currencyEquals(WETH[chainId], outputCurrency)\n  //   ) {\n  //     return {\n  //       wrapType: WrapType.WRAP,\n  //       execute:\n  //         sufficientBalance && inputAmount\n  //           ? async () => {\n  //               try {\n  //                 const txReceipt = await wethContract.deposit({\n  //                   value: `0x${inputAmount.raw.toString(16)}`,\n  //                 });\n  //                 addTransaction(txReceipt, {\n  //                   summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH`,\n  //                 });\n  //               } catch (error) {\n  //                 console.error(\"Could not deposit\", error);\n  //               }\n  //             }\n  //           : undefined,\n  //       inputError: sufficientBalance ? undefined : \"Insufficient ETH balance\",\n  //     };\n  //   } else if (\n  //     currencyEquals(WETH[chainId], inputCurrency) &&\n  //     outputCurrency === ETHER\n  //   ) {\n  //     return {\n  //       wrapType: WrapType.UNWRAP,\n  //       execute:\n  //         sufficientBalance && inputAmount\n  //           ? async () => {\n  //               try {\n  //                 const txReceipt = await wethContract.withdraw(\n  //                   `0x${inputAmount.raw.toString(16)}`\n  //                 );\n  //                 addTransaction(txReceipt, {\n  //                   summary: `Unwrap ${inputAmount.toSignificant(\n  //                     6\n  //                   )} WETH to ETH`,\n  //                 });\n  //               } catch (error) {\n  //                 console.error(\"Could not withdraw\", error);\n  //               }\n  //             }\n  //           : undefined,\n  //       inputError: sufficientBalance ? undefined : \"Insufficient WETH balance\",\n  //     };\n  //   } else {\n  //     return NOT_APPLICABLE;\n  //   }\n  return null;\n  //   }, [\n  //     // wethContract,\n  //     // chainId,\n  //     // inputCurrency,\n  //     // outputCurrency,\n  //     // inputAmount,\n  //     // balance,\n  //     // addTransaction,\n  //   ]);\n}\n"]},"metadata":{},"sourceType":"module"}