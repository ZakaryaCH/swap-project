{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { parseUnits } from \"@ethersproject/units\";\nimport { CurrencyAmount, ETHER, JSBI, Token, TokenAmount } from \"@uniswap/sdk\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport useParsedQueryString from \"../../hooks/useParsedQueryString\";\nimport { isAddress } from \"../../utils\";\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from \"./actions\";\nexport function useSwapState() {\n  _s();\n\n  return useSelector(state => state.swap);\n}\n\n_s(useSwapState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useSwapActionHandlers() {\n  _s2();\n\n  const dispatch = useDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : currency === ETHER ? \"ETH\" : \"\"\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n} // try to parse a user entered amount for a given token\n\n_s2(useSwapActionHandlers, \"oIW3xZhV8GZLW5UVB2t9AN9x/ck=\", false, function () {\n  return [useDispatch];\n});\n\nexport function tryParseAmount(value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n\n    if (typedValueParsed !== \"0\") {\n      return currency instanceof Token ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed)) : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  } // necessary for all paths to return a value\n\n\n  return undefined;\n} // const BAD_RECIPIENT_ADDRESSES: string[] = [\n//   '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f', // v2 factory\n//   '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a', // v2 router 01\n//   '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D' // v2 router 02\n// ]\n\nconst BAD_RECIPIENT_ADDRESSES = [\"0xe2983AeD183e45dF4249A69Bb9D4cB1e79f5990F\", // v2 factory\n\"0xf164fC0Ec4E93095b804a4795bBe1e041497b92a\", // v2 router 01\n\"0xa743c67f4c888713534BDC6b25C3CF41aD3B4Bc6\" // v2 router 02\n];\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\n\nfunction involvesAddress(trade, checksummedAddress) {\n  return trade.route.path.some(token => token.address === checksummedAddress) || trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress);\n} // from the current swap inputs, compute the best trade and return it.\n\n\nexport function useDerivedSwapInfo() {\n  return null;\n}\n\nfunction parseCurrencyFromURLParameter(urlParam) {\n  var _ETH;\n\n  if (typeof urlParam === \"string\") {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === \"ETH\") return \"ETH\";\n    if (valid === false) return \"ETH\";\n  }\n\n  return (_ETH = \"ETH\") !== null && _ETH !== void 0 ? _ETH : \"\";\n}\n\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === \"string\" && !isNaN(parseFloat(urlParam)) ? urlParam : \"\";\n}\n\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === \"string\" && urlParam.toLowerCase() === \"output\" ? Field.OUTPUT : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== \"string\") return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs) {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === \"string\") {\n      inputCurrency = \"\";\n    } else {\n      outputCurrency = \"\";\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n} // updates the swap state to use the defaults for a given network\n\nexport function useDefaultsFromURLSearch() {\n  _s3();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState();\n  useEffect(() => {\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n    dispatch(replaceSwapState({\n      typedValue: parsed.typedValue,\n      field: parsed.independentField,\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n      recipient: parsed.recipient\n    }));\n    setResult({\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n  return result;\n}\n\n_s3(useDefaultsFromURLSearch, \"2CnDlZ82rqfhhBu4OPGgJbxv0gQ=\", false, function () {\n  return [useActiveWeb3React, useDispatch, useParsedQueryString];\n});","map":{"version":3,"sources":["/Users/chichke/Documents/Work/Freelance/swap-project/src/state/swap/hooks.ts"],"names":["parseUnits","CurrencyAmount","ETHER","JSBI","Token","TokenAmount","useCallback","useEffect","useState","useDispatch","useSelector","useActiveWeb3React","useParsedQueryString","isAddress","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapState","state","swap","useSwapActionHandlers","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","ether","error","console","debug","BAD_RECIPIENT_ADDRESSES","involvesAddress","trade","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","parseCurrencyFromURLParameter","urlParam","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","OUTPUT","INPUT","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","inputCurrency","outputCurrency","exactAmount","independentField","exactField","useDefaultsFromURLSearch","chainId","result","setResult","parsed","inputCurrencyId","outputCurrencyId"],"mappings":"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","sourcesContent":["import useENS from \"../../hooks/useENS\";\nimport { Version } from \"../../hooks/useToggledVersion\";\nimport { parseUnits } from \"@ethersproject/units\";\nimport {\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Token,\n  TokenAmount,\n  Trade,\n} from \"@uniswap/sdk\";\nimport { ParsedQs } from \"qs\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useV1Trade } from \"../../data/V1\";\nimport { useActiveWeb3React } from \"../../hooks\";\nimport { useCurrency } from \"../../hooks/Tokens\";\nimport useParsedQueryString from \"../../hooks/useParsedQueryString\";\nimport { isAddress } from \"../../utils\";\nimport { AppDispatch, AppState } from \"../index\";\nimport {\n  Field,\n  replaceSwapState,\n  selectCurrency,\n  setRecipient,\n  switchCurrencies,\n  typeInput,\n} from \"./actions\";\nimport { SwapState } from \"./reducer\";\nimport useToggledVersion from \"../../hooks/useToggledVersion\";\nimport { useUserSlippageTolerance } from \"../user/hooks\";\nimport { computeSlippageAdjustedAmounts } from \"../../utils/prices\";\n\nexport function useSwapState(): AppState[\"swap\"] {\n  return useSelector<AppState, AppState[\"swap\"]>((state) => state.swap);\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Currency) => void;\n  onSwitchTokens: () => void;\n  onUserInput: (field: Field, typedValue: string) => void;\n  onChangeRecipient: (recipient: string | null) => void;\n} {\n  const dispatch = useDispatch<AppDispatch>();\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId:\n            currency instanceof Token\n              ? currency.address\n              : currency === ETHER\n              ? \"ETH\"\n              : \"\",\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }));\n    },\n    [dispatch]\n  );\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }));\n    },\n    [dispatch]\n  );\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  };\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(\n  value?: string,\n  currency?: Currency\n): CurrencyAmount | undefined {\n  if (!value || !currency) {\n    return undefined;\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n    if (typedValueParsed !== \"0\") {\n      return currency instanceof Token\n        ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed))\n        : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  }\n  // necessary for all paths to return a value\n  return undefined;\n}\n\n// const BAD_RECIPIENT_ADDRESSES: string[] = [\n//   '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f', // v2 factory\n//   '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a', // v2 router 01\n//   '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D' // v2 router 02\n// ]\n\nconst BAD_RECIPIENT_ADDRESSES: string[] = [\n  \"0xe2983AeD183e45dF4249A69Bb9D4cB1e79f5990F\", // v2 factory\n  \"0xf164fC0Ec4E93095b804a4795bBe1e041497b92a\", // v2 router 01\n  \"0xa743c67f4c888713534BDC6b25C3CF41aD3B4Bc6\", // v2 router 02\n];\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some((token) => token.address === checksummedAddress) ||\n    trade.route.pairs.some(\n      (pair) => pair.liquidityToken.address === checksummedAddress\n    )\n  );\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): null {\n  return null;\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any): string {\n  if (typeof urlParam === \"string\") {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === \"ETH\") return \"ETH\";\n    if (valid === false) return \"ETH\";\n  }\n  return \"ETH\" ?? \"\";\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === \"string\" && !isNaN(parseFloat(urlParam))\n    ? urlParam\n    : \"\";\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === \"string\" && urlParam.toLowerCase() === \"output\"\n    ? Field.OUTPUT\n    : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX =\n  /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== \"string\") return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === \"string\") {\n      inputCurrency = \"\";\n    } else {\n      outputCurrency = \"\";\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  };\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | {\n      inputCurrencyId: string | undefined;\n      outputCurrencyId: string | undefined;\n    }\n  | undefined {\n  const { chainId } = useActiveWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] =\n    useState<\n      | {\n          inputCurrencyId: string | undefined;\n          outputCurrencyId: string | undefined;\n        }\n      | undefined\n    >();\n\n  useEffect(() => {\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n        recipient: parsed.recipient,\n      })\n    );\n\n    setResult({\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}